<h2 style="text-align: center">Two Pointers Problems</h2>
<br />

<div class="custom-container">
  <h5>Introduction to Two Pointers Technique</h5>
  <p>
    The Two Pointers technique is a powerful algorithmic approach used to solve array and string problems efficiently. 
    It involves using two pointers that traverse the data structure from different positions, typically from both ends 
    or moving at different speeds. This technique is particularly useful for problems involving sorted arrays, palindromes, 
    and finding pairs that meet certain conditions.
  </p>
  <p>
    <strong>Key Benefits:</strong>
  </p>
  <ul>
    <li><strong>Time Complexity:</strong> Often reduces O(n²) solutions to O(n)</li>
    <li><strong>Space Complexity:</strong> Usually O(1) extra space</li>
    <li><strong>Efficiency:</strong> Single pass through the array/string</li>
  </ul>
  <p>
    <strong>Common Patterns:</strong>
  </p>
  <ul>
    <li><strong>Opposite Ends:</strong> One pointer at start, one at end, moving towards each other</li>
    <li><strong>Fast and Slow:</strong> Two pointers moving at different speeds (used in cycle detection)</li>
    <li><strong>Sliding Window:</strong> Two pointers maintaining a window of elements</li>
  </ul>
</div>

<hr />

<div class="custom-container">
  <h5>Table of Contents</h5>
  <ol>
    <li><a href="#validPalindrome">Valid Palindrome</a></li>
    <li><a href="#twoSum">Two Sum - Sorted Array</a></li>
    <li><a href="#threeSum">Three Sum</a></li>
    <li><a href="#containerWater">Container With Most Water</a></li>
    <li><a href="#removeDuplicates">Remove Duplicates from Sorted Array</a></li>
    <li><a href="#trappingRain">Trapping Rain Water</a></li>
    <li><a href="#reverseString">Reverse String</a></li>
    <li><a href="#moveZeroes">Move Zeroes</a></li>
  </ol>
</div>

<hr />

<h5 id="validPalindrome">1. Valid Palindrome</h5>
<p>
  Given a string <code>s</code>, return <code>true</code> if it is a palindrome, or <code>false</code> otherwise.
  A palindrome is a string that reads the same forward and backward, ignoring case and non-alphanumeric characters.
</p>
<p><strong>Approach:</strong> Use two pointers starting from both ends, skip non-alphanumeric characters, and compare characters while moving towards the center.</p>
<pre>
public static boolean isPalindrome(String s) {
    int l = 0, r = s.length() - 1;
    s = s.toLowerCase();

    if (s.isEmpty()) return true;
    while (l &lt;= r) {
        while (l &lt; r && !Character.isLetterOrDigit(s.charAt(l))) l++;
        while (l &lt; r && !Character.isLetterOrDigit(s.charAt(r))) r--;
        if (s.charAt(l) != s.charAt(r)) return false;
        l++;
        r--;
    }
    return true;
}
</pre>
<p><strong>Time Complexity:</strong> O(n) where n is the length of the string</p>
<p><strong>Space Complexity:</strong> O(1)</p>
<p><strong>Example:</strong></p>
<ul>
  <li>Input: "A man, a plan, a canal: Panama" → Output: true</li>
  <li>Input: "race a car" → Output: false</li>
</ul>
<hr />

<h5 id="twoSum">2. Two Sum - Sorted Array</h5>
<p>
  Given a sorted array of integers and a target value, find two numbers that add up to the target. 
  Return the 1-based indices of the two numbers.
</p>
<p><strong>Approach:</strong> Since the array is sorted, use two pointers at opposite ends. If sum is less than target, move left pointer right. If sum is greater, move right pointer left.</p>
<pre>
public int[] twoSum(int[] numbers, int target) {
    int left = 0, right = numbers.length - 1;
    while (left &lt; right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            return new int[]{left + 1, right + 1};
        } else if (sum &lt; target) {
            left++;
        } else {
            right--;
        }
    }
    return new int[]{-1, -1};
}
</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p><strong>Space Complexity:</strong> O(1)</p>
<p><strong>Example:</strong></p>
<ul>
  <li>Input: numbers = [2,7,11,15], target = 9 → Output: [1,2]</li>
  <li>Input: numbers = [2,3,4], target = 6 → Output: [1,3]</li>
</ul>
<hr />

<h5 id="threeSum">3. Three Sum</h5>
<p>
  Given an integer array, find all unique triplets that sum to zero. The solution set must not contain duplicate triplets.
</p>
<p><strong>Approach:</strong> Sort the array first. For each element, use two pointers to find pairs that sum to the negative of that element.</p>
<pre>
public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
    Arrays.sort(nums);
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    
    for (int i = 0; i &lt; nums.length - 2; i++) {
        if (i &gt; 0 && nums[i] == nums[i-1]) continue; // Skip duplicates
        
        int left = i + 1, right = nums.length - 1;
        while (left &lt; right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                while (left &lt; right && nums[left] == nums[left+1]) left++;
                while (left &lt; right && nums[right] == nums[right-1]) right--;
                left++;
                right--;
            } else if (sum &lt; 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
</pre>
<p><strong>Time Complexity:</strong> O(n²)</p>
<p><strong>Space Complexity:</strong> O(1) excluding result array</p>
<hr />

<h5 id="containerWater">4. Container With Most Water</h5>
<p>
  Given an array of heights representing vertical lines, find two lines that together with the x-axis form a container 
  that holds the most water.
</p>
<p><strong>Approach:</strong> Start with two pointers at both ends. Calculate area and move the pointer pointing to the shorter line.</p>
<pre>
public int maxArea(int[] height) {
    int left = 0, right = height.length - 1;
    int maxArea = 0;
    
    while (left &lt; right) {
        int width = right - left;
        int currentArea = Math.min(height[left], height[right]) * width;
        maxArea = Math.max(maxArea, currentArea);
        
        if (height[left] &lt; height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return maxArea;
}
</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p><strong>Space Complexity:</strong> O(1)</p>
<hr />

<h5 id="removeDuplicates">5. Remove Duplicates from Sorted Array</h5>
<p>
  Given a sorted array, remove duplicates in-place such that each element appears only once. 
  Return the number of unique elements.
</p>
<p><strong>Approach:</strong> Use two pointers - one to iterate through the array and one to track the position of unique elements.</p>
<pre>
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    
    int uniqueIndex = 0;
    for (int i = 1; i &lt; nums.length; i++) {
        if (nums[i] != nums[uniqueIndex]) {
            uniqueIndex++;
            nums[uniqueIndex] = nums[i];
        }
    }
    return uniqueIndex + 1;
}
</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p><strong>Space Complexity:</strong> O(1)</p>
<hr />

<h5 id="trappingRain">6. Trapping Rain Water</h5>
<p>
  Given an array representing elevation map, compute how much water it can trap after raining.
</p>
<p><strong>Approach:</strong> Use two pointers with two variables to track maximum heights from left and right.</p>
<pre>
public int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    
    while (left &lt; right) {
        if (height[left] &lt; height[right]) {
            if (height[left] &gt;= leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] &gt;= rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }
    return water;
}
</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p><strong>Space Complexity:</strong> O(1)</p>
<hr />

<h5 id="reverseString">7. Reverse String</h5>
<p>
  Write a function that reverses a string. The input string is given as an array of characters. 
  You must do this in-place with O(1) extra memory.
</p>
<pre>
public void reverseString(char[] s) {
    int left = 0, right = s.length - 1;
    while (left &lt; right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left++;
        right--;
    }
}
</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p><strong>Space Complexity:</strong> O(1)</p>
<hr />

<h5 id="moveZeroes">8. Move Zeroes</h5>
<p>
  Given an integer array, move all 0's to the end while maintaining the relative order of non-zero elements. 
  Do this in-place without making a copy of the array.
</p>
<pre>
public void moveZeroes(int[] nums) {
    int nonZeroIndex = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        if (nums[i] != 0) {
            nums[nonZeroIndex++] = nums[i];
        }
    }
    while (nonZeroIndex &lt; nums.length) {
        nums[nonZeroIndex++] = 0;
    }
}
</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p><strong>Space Complexity:</strong> O(1)</p>
<hr />

<h5>Summary</h5>
<p>
  The Two Pointers technique is essential for solving many array and string problems efficiently. 
  The key is to identify when this pattern applies - typically with sorted arrays, palindromes, 
  or when you need to find pairs meeting certain conditions. Practice these problems to master 
  this fundamental algorithmic technique.
</p>
