<h2 style="text-align: center;">Microservice Interview - Part - 1</h2>
<br>
<div class="custom-container">
  <h5>Table of Contents</h5>
  <ol>
      <li><a href="#"></a></li>
  </ol>
</div>
<hr>
    <h5 id="coupling">What is coupling in microservices? Can you explain with an example.</h5>
    <b>1. Definition of Coupling</b>
    <ul>
    <li>Coupling is the degree of dependency between two components or services.</li>
    <li><b>Tight coupling</b> â†’ direct dependency on concrete classes.</li>
    <li><b>Loose coupling</b> â†’ dependency only on abstractions (interfaces, contracts, or APIs).</li>
    </ul>

    <b>2. Coupling in Microservices</b>
    <ul>
    <li>Microservices should be <b>independently deployable, testable, and scalable</b>.</li>
    <li>If services are tightly coupled:
        <ul>
        <li>A change in one service forces changes in another.</li>
        <li>Harder to scale or deploy independently.</li>
        </ul>
    </li>
    <li>Loose coupling is achieved via:
        <ul>
        <li>Interfaces (inside code).</li>
        <li>REST/gRPC APIs instead of direct DB calls.</li>
        <li>Asynchronous messaging (Kafka, RabbitMQ).</li>
        </ul>
    </li>
    </ul>

    <b>3. Example â€“ Tight Coupling (Bad Practice)</b>
    <pre>
    @Service
    public class UserService {
        private final EmailSender emailSender; // depends on concrete class

        public UserService(EmailSender emailSender) {
            this.emailSender = emailSender;
        }

        public void registerUser(String email) {
            System.out.println("User registered: " + email);
            emailSender.sendEmail(email, "Welcome!"); // hard-coded dependency
        }
    }
    </pre>
    <ul>
    <li>ðŸ”´ <b>Problem:</b> If tomorrow we want SMS notifications, we must change <b>UserService</b> code.</li>
    </ul>

    <b>4. Example â€“ Loose Coupling (Good Practice with Interface)</b>
    <pre>
    public interface NotificationService {
        void send(String to, String message);
    }

    @Service("emailSender")
    public class EmailSender implements NotificationService {
        public void send(String to, String message) {
            System.out.println("Email sent to " + to + ": " + message);
        }
    }

    @Service
    public class UserService {
        private final NotificationService notificationService; // depends on abstraction

        public UserService(@Qualifier("emailSender") NotificationService notificationService) {
            this.notificationService = notificationService;
        }

        public void registerUser(String email) {
            System.out.println("User registered: " + email);
            notificationService.send(email, "Welcome!"); // flexible
        }
    }
    </pre>
    <ul>
    <li>ðŸŸ¢ <b>Benefits:</b>
        <ul>
        <li>Can easily switch to <b>SmsSender</b> or <b>PushNotificationSender</b> without changing <b>UserService</b>.</li>
        <li>Easier unit testing (mock <b>NotificationService</b>).</li>
        <li>Follows <b>Open/Closed Principle</b> (open for extension, closed for modification).</li>
        </ul>
    </li>
    </ul>

    <b>5. How Coupling Relates to Microservices</b>
    <ul>
    <li>In microservices, <b>loose coupling is essential</b>:</li>
    <li>Services should communicate via APIs or events, not internal implementations.</li>
    <li>Each service should evolve independently without breaking others.</li>
    <li><b>Example:</b> Instead of <b>UserService</b> directly calling <b>EmailService</b> database, it should call <b>EmailService API</b> or publish an event.</li>
    </ul>
<hr>