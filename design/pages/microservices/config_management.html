<div class="story">
    <h2 style="text-align: center;">Configurations Management in Microservices</h2>
        <hr>
        <p>
            You're developing a microservice called <b>Account Service</b> using Spring Boot. The application needs to be deployed across multiple environments (dev, qa, prod) with different configurations. The goal is to:
        </p>
        <ul>
            <li>Manage environment-specific configurations without hardcoding them in the codebase.</li>
            <li>Ensure sensitive data like database credentials are stored securely.</li>
            <li>Allow the application to refresh its configuration dynamically across environments using <b>Spring Cloud Bus and Spring Cloud Config Monitor</b>.</li>
        </ul>

    <div class="act act-1">
        <h3 class="section-title">Step 1: Setting Up the Configurations</h3>
        <p>
            To address these challenges, we'll use Spring Boot profiles and externalize configurations:
        </p>

        <div class="section">
            <h4>Environment-Specific Configuration Files</h4>
            <p>Create <code>application.yml</code> for common settings and environment-specific files (<code>application-dev.yml</code>, <code>application-qa.yml</code>, <code>application-prod.yml</code>) for custom properties.</p>
            <div class="code">
                <h5>Example:</h5>
<b>application.yml:</b>
<pre><code>
spring:
  application:
    name: account-service
logging:
  level:
    root: INFO
</code></pre>

<b>application-dev.yml:</b>
<pre><code>
datasource:
  url: jdbc:mysql://dev-db:3306/accounts
  username: dev_user
</code></pre>

<b>application-qa.yml:</b>
<pre><code>
datasource:
  url: jdbc:mysql://qa-db:3306/accounts
  username: qa_user
</code></pre>

<b>application-prod.yml:</b>
<pre><code>
datasource:
  url: jdbc:mysql://prod-db:3306/accounts
  username: prod_user
 </code></pre>

            </div>
        </div>

        <div class="section">
            <h4>Secure Database Credentials</h4>
            <p>Use <strong>AWS Secrets Manager</strong> to securely store sensitive data like database passwords.</p>
            <ul>
                <li>Store environment-specific secrets (<code>account-service-dev-db-creds</code>, <code>account-service-qa-db-creds</code>, <code>account-service-prod-db-creds</code>).</li>
            </ul>
        </div>

        <div class="section">
            <h4>Centralized Configuration Management</h4>
            <p>Use Spring Cloud Config Server to pull properties from a Git repository:</p>
            <div class="code">
                <h5>Repository Structure:</h5>
                <pre><code>
config-repo/
  account-service-dev.yml
  account-service-qa.yml
  account-service-prod.yml
                </code></pre>
            </div>
        </div>
    </div>

    <div class="act act-2">
        <h3 class="section-title">Step 2: Building a Flexible CI/CD Pipeline</h3>
        <p>
            Now, let's set up a Jenkins pipeline to automate builds and deployments:
        </p>

        <div class="section">
            <h4>Configuring Jenkins for Parameterized Deployment</h4>
            <p>Create a parameterized Jenkins job with a dropdown to select the target environment:</p>
            <div class="code">
                <pre><code>
parameters {
    choice(name: 'ENVIRONMENT', choices: ['dev', 'qa', 'prod'], description: 'Select the deployment environment')
}
                </code></pre>
            </div>
        </div>

        <div class="section">
            <h4>Setting the Profile Dynamically</h4>
            <div class="code">
                <pre><code>
environment {
    SPRING_PROFILES_ACTIVE = "${params.ENVIRONMENT}"
}
                </code></pre>
            </div>
        </div>

        <div class="section">
            <h4>Pipeline Stages</h4>
            <div class="code">
                <h5>Checkout Code:</h5>
                <pre><code>
stage('Checkout Code') {
    steps {
        checkout scm
    }
}
                </code></pre>

                <h5>Build the Application:</h5>
                <pre><code>
stage('Build') {
    steps {
        sh 'mvn clean package'
    }
}
                </code></pre>

                <h5>Deploy the Application:</h5>
                <pre><code>
stage('Deploy') {
    steps {
        sh "java -Dspring.profiles.active=${SPRING_PROFILES_ACTIVE} -jar target/account-service.jar"
    }
}
                </code></pre>
            </div>
        </div>
    </div>

    <div class="act act-3">
        <h3 class="section-title">Step 3: Deploying Across Environments</h3>
        <p>
            When the pipeline is executed:
        </p>
        <ol>
            <li>The user selects the target environment (e.g., <code>qa</code>) from the Jenkins job dropdown.</li>
            <li>Jenkins sets <code>SPRING_PROFILES_ACTIVE</code> to <code>qa</code> and starts the deployment process.</li>
            <li>During the application startup, Spring Boot loads environment-specific properties and fetches sensitive credentials from <strong>AWS Secrets Manager</strong>.</li>
        </ol>
    </div>

    <div class="act act-4">
        <h3 class="section-title">Step 4: Handling Secrets Securely</h3>
        <p>
            To handle sensitive credentials securely:
        </p>
        <ul>
            <li>Store secrets in AWS Secrets Manager for each environment.</li>
            <li>Use the AWS SDK to fetch secrets at runtime:</li>
        </ul>
        <div class="code">
            <pre><code>
@Configuration
public class SecretsConfig {
    @Bean
    public String dbPassword() {
        AWSSecretsManager secretsManager = AWSSecretsManagerClientBuilder.standard()
            .withRegion("us-east-1")
            .build();
        String secretValue = secretsManager.getSecretValue(new GetSecretValueRequest()
            .withSecretId("account-service-" + System.getProperty("spring.profiles.active") + "-db-creds"))
            .getSecretString();
        return new JSONObject(secretValue).getString("password");
    }
}
            </code></pre>
        </div>
    </div>

    <div class="act act-5">
        <h3 class="section-title">Step 5: Deployment on Kubernetes</h3>
        <p>
            For Kubernetes deployment:
        </p>
        <ul>
            <li>Use a <strong>ConfigMap</strong> for non-sensitive properties and a <strong>Secret</strong> for credentials.</li>
            <li>Pass <code>SPRING_PROFILES_ACTIVE</code> as an environment variable in the deployment YAML:</li>
        </ul>
        <div class="code">
            <pre><code>
env:
- name: SPRING_PROFILES_ACTIVE
  value: "qa"
            </code></pre>
        </div>
    </div>

    <div class="act act-6">
        <h3 class="section-title">Step 6: Refreshing Configurations at Runtime</h3>
        <p>
            To allow the application to refresh its configurations dynamically without redeploying:
        </p>
        <ul>
            <li>Integrate Spring Cloud Bus to send refresh events across the environments.</li>
            <li>Use Spring Cloud Config Monitor to trigger configuration refresh based on changes in the configuration repository.</li>
        </ul>
        <div class="code">
            <h5>Spring Cloud Bus Setup:</h5>
            <pre><code>
@SpringBootApplication
@EnableConfigServer
@EnableDiscoveryClient
@EnableAutoConfiguration
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
            </code></pre>

            <h5>Spring Cloud Bus Configuration:</h5>
            <pre><code>
@SpringBootApplication
@EnableSpringCloudBus
@EnableConfigServer
@EnableDiscoveryClient
public class AccountServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AccountServiceApplication.class, args);
    }
}
            </code></pre>

            <h5>Application.yml for Config Refresh:</h5>
            <pre><code>
spring:
  cloud:
    config:
      monitor:
        enabled: true
      bus:
        refresh:
          applications: account-service
            </code></pre>

            <h5>Runtime Refresh Controller:</h5>
            <pre><code>
@RestController
public class ConfigRefreshController {

    private final ConfigurableApplicationContext context;

    @Autowired
    public ConfigRefreshController(ConfigurableApplicationContext context) {
        this.context = context;
    }

    @GetMapping("/refresh")
    public ResponseEntity<String> refreshConfig() {
        context.publishEvent(new RefreshEvent(this));
        return ResponseEntity.ok("Configuration refreshed!");
    }
}
            </code></pre>
        </div>

        <h4>Triggering /refresh Endpoint Automatically</h4>
        <p>
            The <code>/refresh</code> endpoint can be triggered manually via a Jenkins job or automatically upon detecting changes in the Git repository monitored by Spring Cloud Config Monitor:
        </p>
        <ul>
            <li><strong>Jenkins Integration:</strong> Configure Jenkins to periodically check for changes in the Git repository. If changes are detected, trigger the <code>/refresh</code> endpoint.</li>
            <li><strong>Manual Trigger:</strong> Developers can manually trigger the <code>/refresh</code> endpoint by accessing the endpoint URL through a browser or a REST client.</li>
        </ul>
    </div>

    <div class="climax">
        <h3 class="section-title">Climax: Automated and Flexible Deployment</h3>
        <p>
            With the pipeline in place:
        </p>
        <ul>
            <li><strong>The build artifact is the same for all environments</strong> (no code changes for `dev`, `qa`, `prod`).</li>
            <li><strong>Jenkins dynamically applies the correct profile</strong> and deploys the application with environment-specific configurations and secrets.</li>
            <li><strong>Updates to configurations are automatically picked up</strong> through Spring Cloud Config Monitor.</li>
            <li><strong>Spring Cloud Bus enables seamless refresh</strong> of configurations at runtime.</li>
        </ul>
    </div>

    <div class="resolution">
        <h3 class="section-title">Resolution: Seamless CI/CD Workflow</h3>
        <p>
            The team now enjoys:
            <ul>
                <li><strong>Centralized Configuration</strong>: Managed via Git and AWS Secrets Manager.</li>
                <li><strong>Secure Credentials</strong>: Protected by AWS Secrets Manager.</li>
                <li><strong>Dynamic Deployments</strong>: Profiles are set dynamically without modifying the codebase.</li>
                <li><strong>Automated Configuration Refresh</strong>: Managed through Spring Cloud Bus and Config Monitor.</li>
            </ul>
        </p>
    </div>
</div>
