<title>Java Collection Framework Interview Guide</title>
<meta name="description"
  content="A complete Java Collection Framework Interview Guide covering List, Set, Map, Queue, Iterator, Comparable vs Comparator, HashMap vs Hashtable, and best practices with examples.">
<meta name="keywords"
  content="Java Collection Framework, Java Collections, List, Set, Map, Queue, Iterator, Comparable, Comparator, HashMap vs Hashtable, Java Interview Questions">
<meta name="robots" content="index, follow">
<meta name="author" content="Preparation Zone">

<link rel="canonical" href="https://www.preparationzone.com/#design/pages/java/java-collection-framework-guide.html" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Java Collection Framework Interview Guide",
  "description": "A complete Java Collection Framework Interview Guide covering List, Set, Map, Queue, Iterator, Comparable vs Comparator, HashMap vs Hashtable, and best practices with examples.",
  "url": "https://www.preparationzone.com/#design/pages/java/java-collection-framework-guide.html",
  "publisher": {
    "@type": "Organization",
    "name": "Preparation Zone",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.preparationzone.com/images/logo.png"
    }
  }
}
</script>

<h2 style="text-align: center;">Collection Framework</h2>
<br>
<div class="custom-container">
  <h5>Table of Contents</h5>
  <ol>
    <b>Collection Interface:</b>
    <li><a href="#limitation of object Arrays">What are limitation of object Arrays?</a></li>
    <li><a href="#arrays and collections">What are differences between arrays and collections?</a></li>
    <li><a href="#Arrays and ArrayList">What are differences between Arrays and ArrayList?</a></li>
    <li><a href="#Collection API">What is Collection API?</a></li>
    <li><a href="#interfaces Collection Framework">What are the key interfaces in the Java Collection Framework?</a>
    </li>
    <li><a href="#Collections and Collection">What is difference between Collections and Collection?</a></li>
    <li><a href="#CI Cloneable Serializable">Why is the Collection interface not extended from the Cloneable and
        Serializable interfaces?</a></li>
    <li><a href="#Collection, List, Set, and Queue">What are the differences between Collection, List, Set, and Queue?
      </a></li>
  </ol>
  <hr class="thin-line">

  <ol>
    <b>List:</b>
    <li><a href="#LI">Explain about List Interface</a></li>
    <li><a href="#ArrayList">Explain about ArrayList Class</a></li>
    <li><a href="#ALSize">What is the default size of an ArrayList?</a></li>
    <li><a href="#ensureCapacity">How does ensureCapacity() work in ArrayList?</a></li>
    <li><a href="#ALImpl">What is the internal implementation of ArrayList in Java?</a></li>
    <li><a href="#ALInsert">What happens when an element is inserted into the middle of an ArrayList?</a></li>
    <li><a href="#ALScenario">A bank transaction history feature requires fast access by index but also frequent
        updates. Which list implementation will you use?</a></li>
    <li><a href="#LLClass">Explain about LinkedList Class</a></li>
    <li><a href="#SynchAL">How to Get a Synchronized Version of ArrayList</a></li>
    <li><a href="#LLAL">Difference Between ArrayList and LinkedList</a></li>
    <li><a href="#EnumItr">Difference Between Enumeration and Iterator</a></li>
    <li><a href="#FFastFSafe">What is the difference between fail-fast and fail-safe iterators?</a></li>
    <li><a href="#ItrLItr">Difference Between Iterator and ListIterator</a></li>
  </ol>
  <hr class="thin-line">
  <ul>
    <li><a href="#comp">Comparision Between Comparable and Comparator</a></li>
  </ul>
  <hr class="thin-line">

  <ol>
    <b>Set:</b>
    <li><a href="#SI">Explain Set Interface</a></li>
    <li><a href="#SSI">Explain SortedSet Interface</a></li>
    <li><a href="#NI">Explain NavigableSet Interface</a></li>
    <li><a href="#HSet">Explain HashSet Class</a></li>
    <li><a href="#DHSLHSTS">What is the difference between <b>HashSet</b>, <b>LinkedHashSet</b>, and <b>TreeSet</b>?</a>
    </li>
    <li><a href="#HSNull">Why does HashSet allow only one null value?</a></li>
    <li><a href="#HSUniq">How does HashSet maintain uniqueness?</a></li>
    <li><a href="#HSDup">What Happens When You Try to Insert Duplicate Values in a Set?</a></li>
    <li><a href="#LHS">LinkedHashSet Class</a></li>
    <li><a href="#TS">Explain TreeSet Class</a></li>
    <li><a href="#TSO">How does TreeSet maintain sorting order?</a></li>
    <li><a href="#HSVSTS">Why is HashSet faster than TreeSet?</a></li>
    <li><a href="#HSScenario">In an authentication system, you need to store unique user session tokens efficiently.
        Which Set implementation is best?</a></li>
  </ol>
  <hr class="thin-line">

  <ol>
    <b>Map:</b>
    <li><a href="#MI">Map Interface:</a></li>
    <li><a href="#SMI">Explain SortedMap Interface</a></li>
    <li><a href="#NMI">Eplain NavigableMap Interface</a></li>
    <li><a href="#RAI">Explain RandomAccess Interface</a></li>
    <li><a href="#DHMLHM">What are the differences between <b>HashMap</b>, <b>LinkedHashMap</b>, and <b>TreeMap</b>?</a>
    </li>
    <li><a href="#HMImpl">What is the <b>internal structure of HashMap</b> in Java 17?</a></li>
    <li><a href="#HMColl">How does <b>HashMap</b> handle collisions?</a></li>
    <li><a href="#HMLF">What is the <b>load factor in HashMap</b>, and how does it impact performance?</a></li>
    <li><a href="#CHM">Why should you use <b>ConcurrentHashMap</b> instead of <b>HashMap</b> in a multi-threaded
        environment?</a></li>
    <li><a href="#HMCHM">What is the difference between <b>HashMap</b> and <b>ConcurrentHashMap</b>?</a></li>
    <li><a href="#WHM">How does <b>WeakHashMap</b> work, and when should it be used?</a></li>
    <li><a href="#TMap">Explain about TreeMap</a></li>
    <li><a href="#HMNull">Why does <b>HashMap</b> allow one null key but multiple null values?</a></li>
    <li><a href="#HMSize">Explain the <b>resize()</b> operation in HashMap</a></li>
    <li><a href="#HMScenario">You need to implement a <b>caching mechanism</b> for a high-traffic website. Which Map
        implementation will you use?</a></li>
    <li><a href="#HMLRU">You are designing an <b>LRU Cache</b> for an e-commerce platform. Which Map implementation is
        suitable?</a></li>
    <li><a href="#HMScenario1">In a <b>trading system</b>, you need to store <b>orders with unique IDs sorted by
          timestamp</b>. Which Map will you use?</a></li>
    <li><a href="#CustomHM">How would you <b>implement your own custom HashMap</b>?</a></li>
  </ol>
  <hr class="thin-line">

  <ol>
    <b>Queue</b>
    <li><a href="#QI">Queue Interface</a></li>
    <li><a href="#QS">What is the difference between <b>Queue and Stack</b>?</a></li>
    <li><a href="#PQ">How does <b>PriorityQueue</b> work internally?</a></li>
    <li><a href="#ADQLDQ">How does <b>ArrayDeque</b> differ from <b>LinkedList-based Deque</b>?</a></li>
    <li><a href="#TSQ">How would you implement a <b>Task Scheduler</b> using a Queue?</a></li>
  </ol>
  <hr class="thin-line">

  <ol>
    <b>Thread-Safe Collection</b>
    <li><a href="#SyncConcu">What are <b>synchronized collections vs concurrent collections?</b> </a></li>
    <li><a href="#COWA">How does <b>CopyOnWriteArrayList</b> differ from a synchronized list?</a></li>
    <li><a href="#CHMHT">How does <b>ConcurrentHashMap</b> handle concurrency differently than <b>HashTable</b>?</a>
    </li>
    <li><a href="#CSLM">Why is <b>ConcurrentSkipListMap</b> useful in multi-threaded applications?</a></li>
    <li><a href="#TSScenraio">In a <b>multi-threaded data processing system</b>, how would you handle concurrent updates
        to a shared collection?</a></li>
  </ol>
</div>
<hr>
<div>
  <b>Quick Revision Diagram:</b>

  <img src="../../images/collection.PNG" class="responsive-image"><br>
  <img src="../../images/collection-map.PNG" class="responsive-image">

</div>
<hr>
<div id="limitation of object Arrays">
  <h5>What are limitation of object Arrays?</h5>
  <p>The limitations of object arrays:</p>
  <ol>
    <li>
      <b>Not Type-Safe:</b>
      <pre>
      Object[] objArray = new Object[3];
      objArray[0] = "Hello";
      objArray[1] = 10; // Adding an integer
      String str = (String) objArray[1]; // ClassCastException at runtime
            </pre>
      This issue arises because object arrays allow storing different types, but improper casting can cause runtime
      errors.
    </li>
    <li>
      <b>Not Suitable for Primitive Types:</b>
      <pre>
      Object[] objArray = new Object[2];
      objArray[0] = 10; // Autoboxing to Integer
      objArray[1] = 20.5; // Autoboxing to Double
      int sum = (Integer) objArray[0] + (Double) objArray[1]; // Requires explicit casting
            </pre>
      Boxing and unboxing can lead to performance degradation and verbose code.
    </li>
    <li>
      <b>Fixed Size:</b>
      <pre>
      Object[] objArray = new Object[3];
      objArray[0] = "Java";
      objArray[1] = "Python";
      objArray[2] = "C++";
      // Adding more elements is not possible, leading to ArrayIndexOutOfBoundsException
      objArray[3] = "JavaScript"; 
            </pre>
      The array cannot grow beyond its defined size.
    </li>

    <li>Operations like searching, inserting, or deleting are not efficient, as arrays lack built-in methods for these
      operations.</li>
    <li>Memory wastage can occur if the array is not fully utilized.</li>
  </ol>
  <p>To overcome these limitations, use collections like <b>ArrayList</b>,
    which are dynamic, type-safe (using generics), and provide built-in methods for efficient operations.</p>
</div>
<hr>

<div id="arrays and collections">
  <h5>What are differences between arrays and collections?</h5>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Arrays</th>
        <th>Collections</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Size</td>
        <td>Fixed in size and cannot grow or shrink dynamically.</td>
        <td>Dynamic in size, can grow or shrink as needed.</td>
      </tr>
      <tr>
        <td>Type Safety</td>
        <td>Homogeneous elements in typed arrays. Object arrays allow mixed types but are not type-safe.</td>
        <td>Generics provide type safety, allowing homogeneous or heterogeneous elements depending on the type
          parameter.</td>
      </tr>
      <tr>
        <td>Performance</td>
        <td>Faster since they are part of the core language and have no additional overhead.</td>
        <td>Relatively slower due to additional features and dynamic resizing.</td>
      </tr>
      <tr>
        <td>Ease of Use</td>
        <td>Requires manual handling for operations like insertion, deletion, or resizing.</td>
        <td>Provides built-in methods for operations like insertion, deletion, sorting, and searching.</td>
      </tr>
      <tr>
        <td>Primitive Types</td>
        <td>Can store primitive types directly.</td>
        <td>Cannot store primitives directly; requires boxing (e.g., Integer for int).</td>
      </tr>
      <tr>
        <td>Memory Utilization</td>
        <td>Efficient memory usage as the size is fixed.</td>
        <td>May lead to memory overhead due to dynamic resizing.</td>
      </tr>
      <tr>
        <td>Hierarchy</td>
        <td>Arrays are part of the core Java language and have no hierarchy.</td>
        <td>Collections are part of the java.util package and follow a defined hierarchy.</td>
      </tr>
      <tr>
        <td>Examples</td>
        <td>int[], String[], Object[]</td>
        <td>ArrayList, LinkedList, HashSet, HashMap, etc.</td>
      </tr>
    </tbody>
  </table>
</div>
<hr>

<div id="Arrays and ArrayList">
  <h5>What are differences between arrays and ArrayList?</h5>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Arrays</th>
        <th>ArrayList</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Size</td>
        <td>Fixed in size and cannot grow or shrink dynamically.</td>
        <td>Dynamic in size, grows or shrinks as needed.</td>
      </tr>
      <tr>
        <td>Type Safety</td>
        <td>Homogeneous elements in typed arrays. Object arrays allow mixed types but are not type-safe.</td>
        <td>Supports generics for type safety, allowing homogeneous elements.</td>
      </tr>
      <tr>
        <td>Performance</td>
        <td>Faster for primitive data types as it does not involve boxing or unboxing.</td>
        <td>Relatively slower due to dynamic resizing and support for only objects (requires boxing for primitives).
        </td>
      </tr>
      <tr>
        <td>Ease of Use</td>
        <td>Requires manual handling for insertion, deletion, and resizing operations.</td>
        <td>Provides built-in methods for operations like add, remove, contains, and more.</td>
      </tr>
      <tr>
        <td>Primitive Types</td>
        <td>Can store primitive types directly (e.g., int, char).</td>
        <td>Cannot store primitives directly; requires wrapper classes (e.g., Integer, Character).</td>
      </tr>
      <tr>
        <td>Memory Utilization</td>
        <td>Memory is allocated at creation time, potentially leading to waste if not fully utilized.</td>
        <td>Manages memory dynamically, though resizing can lead to temporary overhead.</td>
      </tr>
      <tr>
        <td>Methods</td>
        <td>No predefined methods for operations like addition or removal; only basic array operations are supported.
        </td>
        <td>Rich API with methods like <b>add()</b>, <b>remove()</b>, <b>size()</b>, and more.</td>
      </tr>
      <tr>
        <td>Flexibility</td>
        <td>Less flexible, mainly for static storage requirements.</td>
        <td>Highly flexible, suitable for dynamic storage needs.</td>
      </tr>
      <tr>
        <td>Examples</td>
        <td>int[] arr = {1, 2, 3};</td>
        <td>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</td>
      </tr>
    </tbody>
  </table>
</div>
<hr>

<div id="Collection API">
  <h5>What is Collection API?</h5>
  <p>The Collection API in Java is a framework provided in the <b>java.util</b> package to handle groups of objects,
    known as collections.
    It provides a set of classes and interfaces to store, manipulate, and retrieve data efficiently.
    This API helps developers perform data structure-related tasks like searching, sorting, insertion, manipulation, and
    deletion in an easier and more organized way.</p>

  <p><b>Main Features of the Collection API:</b></p>
  <ul>
    <li><b>Interfaces:</b> The core of the Collection API is a set of interfaces like <b>Collection</b>, <b>List</b>,
      <b>Set</b>, <b>Queue</b>, and <b>Map</b>.</li>
    <li><b>Implementations:</b> Includes concrete classes like <b>ArrayList</b>, <b>LinkedList</b>, <b>HashSet</b>,
      <b>TreeSet</b>, <b>HashMap</b>, and <b>TreeMap</b>.</li>
    <li><b>Algorithms:</b> Provides utility classes like <b>Collections</b> to perform tasks such as sorting, searching,
      and shuffling.</li>
    <li><b>Generics Support:</b> Allows type-safe collections, reducing the need for typecasting.</li>
    <li><b>Thread-Safety:</b> Provides synchronized collection classes like <b>Vector</b> and thread-safe utilities in
      the <b>java.util.concurrent</b> package.</li>
    <li><b>Flexibility:</b> Supports dynamic resizing, making it suitable for applications where the data size is
      unpredictable.</li>
  </ul>

  <p><b>Key Interfaces in the Collection API:</b></p>
  <ul>
    <li><b>Collection</b>: The root interface for all collection classes.</li>
    <li><b>List</b>: Ordered collections that allow duplicate elements (e.g., <b>ArrayList</b>, <b>LinkedList</b>).</li>
    <li><b>Set</b>: Collections that do not allow duplicate elements (e.g., <b>HashSet</b>, <b>TreeSet</b>).</li>
    <li><b>Queue</b>: Collections that follow the FIFO (First In, First Out) principle (e.g., <b>PriorityQueue</b>).
    </li>
    <li><b>Map</b>: Key-value pair collections (e.g., <b>HashMap</b>, <b>TreeMap</b>).</li>
  </ul>
</div>
<hr>

<div id="interfaces Collection Framework">
  <h5>What are the key interfaces in the Java Collection Framework? </h5>
  <ol>
    <li><b>Collection Interface:</b></li>
    <p>The root interface of the collection hierarchy, providing basic operations like adding, removing, and checking
      the size of a collection.</p>
    <li><b>List(I):</b></li>
    <ul>
      <li>Insertion order is preserved.</li>
      <li>Duplicates are allowed.</li>
      <li>Implementations: ArrayList, LinkedList, Vector, Stack</li>
    </ul>
    <li><b>Set(I):</b></li>
    <ul>
      <li>Insertion order is not preserved.</li>
      <li>Duplicates are not allowed.</li>
      <li>Implementations: HashSet, LinkedHashSet, TreeSet</li>
    </ul>
    <li><b>SortedSet(I):</b></li>
    <ul>
      <li>Extends Set and maintains elements in a sorted order</li>
      <li>Implementation: TreeSet</li>
    </ul>
    <li><b>Queue(I):</b></li>
    <ul>
      <li>Designed for holding elements before processing them.</li>
      <li>Follows FIFO (First In, First Out) principle.</li>
      <li>Implementations: PriorityQueue, LinkedList (as Queue), ArrayDeque</li>
    </ul>
    <li><b>Deque(I):</b></li>
    <ul>
      <li>Extends Queue and allows insertion and removal from both ends</li>
      <li>Implementations: ArrayDeque, LinkedList (as Deque)</li>
    </ul>
    <li><b>Map(I) (Not Extending Collection)</b></li>
    <ul>
      <li>A key-value pair-based collection that does not allow duplicate keys</li>
      <li>Implementations: HashMap, LinkedHashMap, TreeMap, Hashtable</li>
    </ul>
    <li><b>SortedMap(I):</b></li>
    <ul>
      <li>Extends Map and maintains keys in a sorted order.</li>
      <li>Implementation: TreeMap</li>
    </ul>
  </ol>
</div>
<hr>

<div id="Collections and Collection">
  <h5>What is difference between Collection and Collections?</h5>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Collection</th>
        <th>Collections</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Definition</td>
        <td><b>Collection</b> is an interface in the <b>java.util</b> package that represents a group of objects, also
          known as elements.</td>
        <td><b>Collections</b> is a utility class in the <b>java.util</b> package that provides static methods for
          operations on collections, such as sorting, searching, and synchronization.</td>
      </tr>
      <tr>
        <td>Purpose</td>
        <td>Serves as a root interface for all collection types, such as <b>List</b>, <b>Set</b>, and <b>Queue</b>.</td>
        <td>Provides utility methods to perform common operations on collections, like <b>sort()</b>, <b>reverse()</b>,
          <b>synchronizedList()</b>, etc.</td>
      </tr>
      <tr>
        <td>Inheritance</td>
        <td>Extended by other interfaces such as <b>List</b>, <b>Set</b>, and <b>Queue</b>.</td>
        <td>Does not extend or implement any interface; it is a standalone utility class.</td>
      </tr>
      <tr>
        <td>Usage</td>
        <td>Defines common methods like <b>add()</b>, <b>remove()</b>, <b>size()</b>, and <b>iterator()</b> that are
          implemented by collection classes.</td>
        <td>Provides static methods like <b>sort()</b>, <b>binarySearch()</b>, and <b>synchronizedList()</b> to operate
          on collections.</td>
      </tr>
      <tr>
        <td>Example</td>
        <td>
          <pre>Collection<String> list = new ArrayList<>();
  list.add("Java");</pre>
        </td>
        <td>
          <pre>List<String> list = new ArrayList<>();
  Collections.sort(list);</pre>
        </td>
      </tr>
    </tbody>
  </table>
</div>
<hr>

<div id="CI Cloneable Serializable">
  <h5>Why is the Collection interface not extended from the Cloneable and Serializable interfaces?</h5>
  <b>1. Flexibility in Implementation</b><br>
  <p>The Collection interface is a high-level abstraction, and its implementing classes may have different ways of
    handling cloning and serialization. Enforcing all collection implementations to be Cloneable and Serializable would
    restrict their flexibility.</p><br>
  <b>2. Not All Collections Need Cloning</b><br>
  <p>Some collections, such as live views (e.g., subList in List), do not support cloning because they are directly
    linked to the original collection. Extending Cloneable in the Collection interface would force all implementations
    to support cloning, which may not always be feasible.</p><br>
  <b>3. Not All Collections Should Be Serializable</b><br>
  <p>Serialization is not required for all collections. For example, some collections may store transient data (such as
    caching structures) that should not be persisted. If Collection extended Serializable, every implementation would be
    forced to support serialization, which is unnecessary for many use cases.</p><br>
  <b>4. Separation of Concerns</b><br>
  <p>By keeping Cloneable and Serializable separate, Java allows developers to decide whether their specific collection
    implementation should support these features. Implementing classes like ArrayList, HashSet, and HashMap explicitly
    implement Serializable when needed.</p><br>
  <b>5. Deep vs. Shallow Cloning Complexity</b><br>
  <p>Cloning a collection is not straightforward since it involves either a shallow copy (copying references) or a deep
    copy (copying objects inside the collection). Since the Collection interface does not define how elements should be
    cloned, it is left to individual implementations.</p><br>
  <b>Conclusion</b><br>
  <p>The decision to not extend Cloneable and Serializable in the Collection interface was made to ensure flexibility,
    maintain separation of concerns, and avoid unnecessary constraints on implementing classes. Instead, individual
    collection implementations can choose to support cloning and serialization based on their requirements.</p><br>
</div>
<hr>

<div id="Collection, List, Set, and Queue">
  <h5>What are the differences between Collection, List, Set, and Queue?</h5>
  <ul>
    <li><b>Collection:</b></li>
    <ul>
      <li>Root interface of the Java Collection Framework.</li>
      <li>Defines common methods like <b>add()</b>, <b>remove()</b>, and <b>size()</b>.</li>
      <li>Extended by <b>List</b>, <b>Set</b>, and <b>Queue</b>.</li>
      <li>Does not include <b>Map</b>, as it operates on key-value pairs.</li>
    </ul>

    <li><b>List:</b></li>
    <ul>
      <li>Ordered collection (sequence) of elements.</li>
      <li>Allows duplicate elements.</li>
      <li>Provides positional access via an index.</li>
      <li>Implementations: <b>ArrayList</b>, <b>LinkedList</b>, <b>Vector</b>, <b>Stack</b>.</li>
    </ul>

    <li><b>Set:</b></li>
    <ul>
      <li>Unordered collection that does not allow duplicate elements.</li>
      <li>Elements must be unique and may be sorted (depending on implementation).</li>
      <li>Implementations: <b>HashSet</b> (unordered), <b>LinkedHashSet</b> (insertion order), <b>TreeSet</b> (sorted).
      </li>
    </ul>

    <li><b>Queue:</b></li>
    <ul>
      <li>Follows FIFO (First-In-First-Out) ordering.</li>
      <li>Used for holding elements before processing.</li>
      <li>Variations like PriorityQueue allow elements to be processed in a specific order.</li>
      <li>Implementations: <b>PriorityQueue</b>, <b>LinkedList</b> (as Queue), <b>ArrayDeque</b>.</li>
    </ul>
  </ul>
</div>
<hr>

<div id="LI">
  <h5>Explain about List Interface</h5>
  <p>The <b>List</b> interface is a subinterface of the <b>Collection</b> interface in the <b>java.util</b> package. It
    represents an ordered collection (also known as a sequence) that allows duplicate elements. Elements in a
    <b>List</b> can be accessed by their index, and insertion order is maintained.</p>

  <p><b>Hierarchy:</b></p>
  <ul>
    <li>The <b>List</b> interface extends the <b>Collection</b> interface.</li>
    <li>Some common implementations of the <b>List</b> interface are:
      <ul>
        <li><b>ArrayList</b>: A dynamic array implementation.</li>
        <li><b>LinkedList</b>: A doubly-linked list implementation.</li>
        <li><b>Vector</b>: A synchronized, dynamic array implementation.</li>
        <li><b>Stack</b>: A subclass of <b>Vector</b> implementing a LIFO (Last In, First Out) structure.</li>
      </ul>
    </li>
  </ul>

  <p><b>Key Features of the List Interface:</b></p>
  <ul>
    <li><b>Ordered:</b> Elements are stored and accessed in the order they are added.</li>
    <li><b>Indexed:</b> Allows access to elements by their zero-based index.</li>
    <li><b>Allows Duplicates:</b> Can contain duplicate elements.</li>
  </ul>

  <p><b>Key Methods of the List Interface:</b></p>
  <ul>
    <li><b>void add(int index, E element)</b>: Inserts the specified element at the specified position in the list.</li>
    <li><b>boolean addAll(int index, Collection
        <? extends E> c)</b>: Inserts all elements from the specified collection at the specified position.</li>
          <li><b>E get(int index)</b>: Returns the element at the specified position in the list.</li>
          <li><b>int indexOf(Object o)</b>: Returns the index of the first occurrence of the specified element, or -1 if it is not found.</li>
          <li><b>int lastIndexOf(Object o)</b>: Returns the index of the last occurrence of the specified element, or -1 if it is not found.</li>
          <li><b>E remove(int index)</b>: Removes the element at the specified position in the list.</li>
          <li><b>E set(int index, E element)</b>: Replaces the element at the specified position with the specified element.</li>
          <li><b>List<E> subList(int fromIndex, int toIndex)</b>: Returns a view of the portion of the list between the specified <b>fromIndex</b> (inclusive) and <b>toIndex</b> (exclusive).</li>
        </ul>
        <pre>
          import java.util.List;
          import java.util.ArrayList;
          import java.util.Collection;
          
          public class ListMethodsExample {
              public static void main(String[] args) {
                  // Create a List
                  List<String> fruits = new ArrayList<>();
          
                  // Adding elements using add method
                  fruits.add("Apple");
                  fruits.add("Banana");
                  fruits.add("Mango");
                  fruits.add("Peach");
          
                  // Insert an element at a specific position using add(index, element)
                  <b>fruits.add(1, "Grapes");</b> // Insert Grapes at index 1
        
                  // Insert all elements from another collection using addAll(index, collection)
                  Collection<String> moreFruits = List.of("Pineapple", "Orange");
                  <b>fruits.addAll(2, moreFruits);</b> // Insert at index 2
          
                  // Retrieve an element at a specific index using get(index)
                  System.out.println("Element at index 2: " + fruits.get(2));
          
                  // Find the index of the first occurrence of a specific element using indexOf(object)
                  int indexOfMango = <b>fruits.indexOf("Mango");</b>
          
                  // Find the index of the last occurrence of a specific element using lastIndexOf(object)
                  fruits.add("Apple"); // Adding another Apple to test lastIndexOf
                  int lastIndexOfApple = <b>fruits.lastIndexOf("Apple");</b>
          
                  // Remove an element at a specific index using remove(index)
                  <b>fruits.remove(4);</b> // Removes "Peach"
          
                  // Replace an element at a specific index using set(index, element)
                  <b>fruits.set(2, "Watermelon");</b> // Replace "Mango" with "Watermelon"
          
                  // Get a sublist of the list using subList(fromIndex, toIndex)
                  List<String> sublist = <b>fruits.subList(1, 4);</b> // Get elements from index 1 to 3
                  System.out.println("Sublist of fruits: " + sublist);
              }
          }
                  </pre>
</div>
<hr>

<div id="ArrayList">
    <h5>Explain about ArrayList Class</h5>
    <p>The <b>ArrayList</b> class in <b>java.util</b> is a resizable array implementation of the <b>List</b> interface. It allows dynamic growth and shrinkage of the array as elements are added or removed. <b>ArrayList</b> is one of the most commonly used collection classes in Java for storing and manipulating a group of objects.</p>
  
    <p><b>Key Features of ArrayList:</b></p>
    <ul>
      <li><b>Dynamic Resizing:</b> Automatically grows its size when the capacity is exceeded.</li>
      <li><b>Index-Based Access:</b> Provides fast random access to elements via their index.</li>
      <li><b>Duplicate Elements:</b> Allows duplicate elements and maintains insertion order.</li>
      <li><b>Non-Synchronized:</b> <b>ArrayList</b> is not thread-safe; for concurrent access, use <b>Collections.synchronizedList()</b> or <b>CopyOnWriteArrayList</b>.</li>
      <li><b>Implements:</b> Implements <b>List</b>, <b>RandomAccess</b>, <b>Cloneable</b>, and <b>Serializable</b> interfaces.</li>
    </ul>
  
    <p><b>Key Methods:</b></p>
    <ul>
      <li><b>add(E e)</b>: Adds an element to the end of the list.</li>
      <li><b>get(int index)</b>: Retrieves the element at the specified index.</li>
      <li><b>set(int index, E element)</b>: Replaces the element at the specified index.</li>
      <li><b>remove(int index)</b>: Removes the element at the specified index.</li>
      <li><b>size()</b>: Returns the number of elements in the list.</li>
      <li><b>clear()</b>: Removes all elements from the list.</li>
    </ul>
  
    <p><b>Example Usage:</b></p>
    <pre>
  import java.util.*;
  
  public class ArrayListExample {
      public static void main(String[] args) {
          ArrayList<String> list = new ArrayList<>();
  
          // Adding elements
         <b>list.add("Java");</b>
          list.add("Python");
          list.add("C++");
  
          // Accessing elements
          System.out.println("Element at index 1: " + <b>list.get(1)</b>);
  
          // Updating an element
          <b>list.set(1, "JavaScript");</b>
  
          // Removing an element
          <b>list.remove(2);</b>
  
          // Iterating through the list
          System.out.println("Iterating over the list:");
          for (String s : list) {
              System.out.println(s);
          }
      }
  }
    </pre>
  
    <p><b>Advantages of ArrayList:</b></p>
    <ul>
      <li>Dynamic resizing eliminates the need for manual array resizing.</li>
      <li>Efficient for random access and retrieval of elements.</li>
      <li>Maintains insertion order of elements.</li>
    </ul>
  
    <p><b>Disadvantages of ArrayList:</b></p>
    <ul>
      <li>Not thread-safe for concurrent access.</li>
      <li>Slower than <b>LinkedList</b> for insertions and deletions in the middle of the list.</li>
    </ul>
</div>
<hr>

<div id="ALSize">
  <h5>What is the default size of an ArrayList?</h5>
  <ul>
    <li>The default size of an <b>ArrayList</b> refers to its initial capacity.</li>
    <li>When an <b>ArrayList</b> is created using the default constructor <b>new ArrayList&lt;&gt;()</b>, the initial capacity is <b>10</b>.</li>
    <li>Internally, <b>ArrayList</b> uses an array, which grows dynamically when elements are added.</li>
    <li>When the capacity is exceeded, the new capacity is calculated as <b>oldCapacity + (oldCapacity / 2)</b>, which is <b>1.5 times the previous capacity</b>.</li>
    <li>You can specify an initial capacity explicitly using <b><b>new ArrayList&lt;&gt;(int initialCapacity)</b></b> to optimize memory usage.</li>
</ul>
</div>
<hr>

<div id="ensureCapacity">
  <h5>How does ensureCapacity() work in ArrayList?</h5>
  <ul>
    <li><b>ensureCapacity(int minCapacity)</b> is a method in <b>ArrayList</b> used to increase the capacity of the list to accommodate more elements.</li>
    <li>It helps in optimizing performance by reducing the number of times internal array resizing occurs.</li>
    <li>If the specified <b>minCapacity</b> is greater than the current capacity, the internal array is expanded.</li>
    <li>Internally, <b>ensureCapacity()</b> follows the resizing mechanism of <b>ArrayList</b> (increasing size by 1.5x when needed).</li>
    <li>It is particularly useful when a large number of elements are expected to be added, avoiding frequent reallocation.</li>
    <li>Example usage:</li>
    <pre>
        ArrayList<Integer> list = new ArrayList<>();
        list.ensureCapacity(50); // Ensures the list can hold at least 50 elements
    </pre>
</ul>

</div>
<hr>

<div id="ALImpl">
  <h5>What is the internal implementation of ArrayList in Java?</h5>
<ul>
    <li><b>Underlying Data Structure:</b></li>
    <ul>
        <li><b>ArrayList</b> internally uses a <b>dynamic array</b> to store elements.</li>
        <li>The array grows automatically when more elements are added beyond its capacity.</li>
    </ul>

    <li><b>Default Capacity & Growth:</b></li>
    <ul>
        <li>When created using <b>new ArrayList&lt;&gt;()</b>, it has an initial capacity of <b>10</b>.</li>
        <li>When the array reaches its capacity, a new array is created with <b>1.5 times the previous size</b>, and elements are copied.</li>
    </ul>

    <li><b>Adding Elements:</b></li>
    <ul>
        <li><b>add(E e)</b> appends an element at the end.</li>
        <li><b>add(int index, E e)</b> inserts at a specific index (shifting elements).</li>
        <li>Resizing occurs if needed, using <b>ensureCapacity()</b>.</li>
    </ul>

    <li><b>Accessing Elements:</b></li>
    <ul>
        <li><b>get(int index)</b> retrieves an element in <b>O(1) time complexity</b>.</li>
        <li>Uses direct indexing as it is backed by an array.</li>
    </ul>

    <li><b>Removing Elements:</b></li>
    <ul>
        <li><b>remove(int index)</b> shifts all elements after the removed index.</li>
        <li>Worst-case removal (from start) takes <b>O(n) time complexity</b> due to shifting.</li>
    </ul>

    <li><b>Iteration:</b></li>
    <ul>
        <li>Supports iteration using <b>for</b> loop, <b>for-each</b>, <b>Iterator</b>, and <b>ListIterator</b>.</li>
    </ul>

    <li><b>Thread-Safety:</b></li>
    <ul>
        <li><b>ArrayList</b> is <b>not synchronized</b>, making it <b>not thread-safe</b>.</li>
        <li>For thread-safe operations, use <b>Collections.synchronizedList()</b> or <b>CopyOnWriteArrayList</b>.</li>
    </ul>
</ul>

</div>
<hr>

<div id="ALInsert">
  <h5>What happens when an element is inserted into the middle of an ArrayList?</h5>
<ul>
    <li><b>Shifting Elements:</b></li>
    <ul>
        <li>When an element is inserted at a specific index using <b>add(int index, E element)</b>, all elements from that index onward are shifted to the right.</li>
        <li>This shifting increases the time complexity to <b>O(n)</b> in the worst case.</li>
    </ul>

    <li><b>Resizing If Needed:</b></li>
    <ul>
        <li>If the internal array reaches its capacity, it is resized by <b>1.5x the current size</b>.</li>
        <li>A new array is created, and all elements are copied over, adding extra overhead.</li>
    </ul>

    <li><b>Performance Impact:</b></li>
    <ul>
        <li>Insertion at the middle causes <b>O(n) shifting cost</b>, making it less efficient compared to a <b>LinkedList</b>, which has <b>O(1) insertion time</b> when a reference to the node is available.</li>
    </ul>

    <li><b>Example:</b></li>
    <pre>
        ArrayList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 4, 5));
        list.add(2, 3); // Inserting 3 at index 2
        System.out.println(list); // Output: [1, 2, 3, 4, 5]
    </pre>

    <li><b>Best Practices:</b></li>
    <ul>
        <li>If frequent middle insertions are required, consider using a <b>LinkedList</b> instead of an <b>ArrayList</b>.</li>
        <li>For better performance, use batch processing instead of multiple insertions.</li>
    </ul>
</ul>

</div>
<hr>

<div id="ALScenario">
  <h5>A <b>bank transaction history feature</b> requires fast access by index but also frequent updates. Which list implementation will you use?</h5>

<ul>
    <li><b>Best Choice: <b>ArrayList</b></b></li>
    <ul>
        <li><b>ArrayList</b> provides O(1) time complexity for accessing elements by index.</li>
        <li>Since transaction history needs fast retrieval, <b>ArrayList</b> is a good fit.</li>
    </ul>

    <li><b>Consideration for Updates:</b></li>
    <ul>
        <li>If updates involve modifying existing elements, <b>ArrayList.set(index, element)</b> performs in O(1) time, making it efficient.</li>
        <li>If frequent insertions/removals in the middle occur, shifting elements (O(n) cost) might be a downside.</li>
    </ul>

    <li><b>Alternative: <b>LinkedList</b></b></li>
    <ul>
        <li>If frequent insertions and deletions (e.g., adding/removing transactions dynamically) are required, <b>LinkedList</b> could be considered.</li>
        <li>However, <b>LinkedList</b> has O(n) access time, which makes it slower for index-based retrieval.</li>
    </ul>

    <li><b>Final Decision:</b></li>
    <ul>
        <li>Use <b>ArrayList</b> if fast access by index is the top priority and updates mainly modify existing transactions.</li>
        <li>If frequent middle insertions or deletions are required, a hybrid approach (e.g., <b>ArrayList</b> + indexing techniques like HashMap) might be needed.</li>
    </ul>
</ul>

</div>
<hr>

<div id="LLClass">
    <h5>Explain about LinkedList Class</h5>
    <p>The <b>LinkedList</b> class in <b>java.util</b> is a doubly linked list implementation of the <b>List</b> and <b>Deque</b> interfaces. It allows dynamic memory allocation, where each element is a node containing a reference to the previous and next nodes, making it efficient for insertion and deletion operations.</p>
  
    <p><b>Key Features of LinkedList:</b></p>
    <ul>
      <li><b>Doubly Linked Structure:</b> Each node contains pointers to both the previous and the next nodes.</li>
      <li><b>Dynamic Size:</b> Can grow or shrink dynamically without manual resizing.</li>
      <li><b>Efficient Insertions/Deletions:</b> Particularly efficient for operations at the beginning or middle of the list.</li>
      <li><b>Implements:</b> Implements <b>List</b>, <b>Deque</b>, <b>Cloneable</b>, and <b>Serializable</b> interfaces.</li>
      <li><b>Allows Duplicates:</b> Supports duplicate elements and maintains insertion order.</li>
    </ul>
  
    <p><b>Key Methods:</b></p>
    <ul>
      <li><b>add(E e)</b>: Adds an element to the end of the list.</li>
      <li><b>addFirst(E e)</b>: Adds an element at the beginning of the list.</li>
      <li><b>addLast(E e)</b>: Adds an element at the end of the list.</li>
      <li><b>remove(int index)</b>: Removes the element at the specified index.</li>
      <li><b>get(int index)</b>: Retrieves the element at the specified index.</li>
      <li><b>peek()</b>: Retrieves the head of the list without removing it.</li>
      <li><b>poll()</b>: Retrieves and removes the head of the list.</li>
    </ul>
  
    <p><b>Example Usage:</b></p>
    <pre>
  import java.util.*;
  
  public class LinkedListExample {
      public static void main(String[] args) {
          LinkedList<String> list = new LinkedList<>();
  
          // Adding elements
          list.add("Java");
          list.add("Python");
          list.addFirst("C++");
          list.addLast("JavaScript");
  
          // Displaying the list
          System.out.println("LinkedList: " + list);
  
          // Accessing elements
          System.out.println("First Element: " + list.getFirst());
          System.out.println("Last Element: " + list.getLast());
  
          // Removing elements
          list.removeFirst();
          System.out.println("After removing first element: " + list);
  
          // Using as a Queue
          System.out.println("Polling (Queue operation): " + list.poll());
          System.out.println("LinkedList after poll: " + list);
      }
  }
</pre>
  
    <p><b>Advantages of LinkedList:</b></p>
    <ul>
      <li>Efficient insertions and deletions, especially at the beginning or middle of the list.</li>
      <li>Can be used as both a <b>List</b> and a <b>Deque</b>, supporting stack and queue operations.</li>
      <li>Dynamic resizing eliminates the need for manual array resizing.</li>
    </ul>
  
    <p><b>Disadvantages of LinkedList:</b></p>
    <ul>
      <li>Slower for random access compared to <b>ArrayList</b> due to sequential traversal.</li>
      <li>Consumes more memory because of the storage overhead for node pointers.</li>
    </ul>
</div>
<hr>

<div id="SynchAL">
    <h5>How to Get a Synchronized Version of ArrayList</h5>
    <p>The <b>ArrayList</b> class is not thread-safe by default. To get a synchronized version of an <b>ArrayList</b>, we can use the <b>Collections.synchronizedList()</b> method. This ensures that the <b>ArrayList</b> is synchronized, making it safe for use in multi-threaded environments.</p>
  
    <p><b>Steps to Get a Synchronized ArrayList:</b></p>
    <ol>
      <li>Create an instance of <b>ArrayList</b>.</li>
      <li>Pass the <b>ArrayList</b> to the <b>Collections.synchronizedList()</b> method to obtain a synchronized version of it.</li>
      <li>Use the synchronized list in your program.</li>
    </ol>
  
    <p><b>Example:</b></p>
    <pre>
  import java.util.*;
  
  public class SynchronizedArrayListExample {
      public static void main(String[] args) {
          // Create a regular ArrayList
          <b>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</b>
          arrayList.add("Java");
          arrayList.add("Python");
          arrayList.add("C++");
  
          // Get a synchronized version of the ArrayList
          List&lt;String&gt; synchronizedList = <b>Collections.synchronizedList(arrayList);</b>
  
          // Accessing the synchronized list
          synchronized (synchronizedList) {
              for (String s : synchronizedList) {
                  System.out.println(s);
              }
          }
      }
  }
    </pre>
  
    <p><b>Key Points:</b></p>
    <ul>
      <li>The <b>Collections.synchronizedList()</b> method returns a thread-safe wrapper around the given <b>ArrayList</b>.</li>
      <li>While iterating over the synchronized list, it's recommended to explicitly synchronize on the list to avoid <b>ConcurrentModificationException</b>.</li>
      <li>This approach does not prevent logical issues like race conditions; additional synchronization might still be needed for complex operations.</li>
    </ul>
</div>
<hr>

<div id="LLAL">
    <h5>Difference Between ArrayList and LinkedList</h5>
    <table border="1" cellpadding="5" cellspacing="0">
      <thead>
        <tr>
          <th>Aspect</th>
          <th>ArrayList</th>
          <th>LinkedList</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><b>Implementation</b></td>
          <td>Backed by a dynamic array.</td>
          <td>Implemented as a doubly linked list.</td>
        </tr>
        <tr>
          <td><b>Access Time</b></td>
          <td>Provides fast random access (<b>O(1)</b>) for retrieving elements by index.</td>
          <td>Accessing an element requires traversal, making it slower (<b>O(n)</b>) for random access.</td>
        </tr>
        <tr>
          <td><b>Insertion/Deletion</b></td>
          <td>Slower for insertions and deletions in the middle due to shifting of elements.</td>
          <td>Efficient for insertions and deletions, especially at the beginning or middle (<b>O(1)</b> or <b>O(n)</b> for traversal).</td>
        </tr>
        <tr>
          <td><b>Memory Usage</b></td>
          <td>Consumes less memory as it stores only the elements.</td>
          <td>Consumes more memory due to the storage of node pointers (next and previous).</td>
        </tr>
        <tr>
          <td><b>Iteration</b></td>
          <td>Faster for iteration due to contiguous memory storage.</td>
          <td>Slightly slower for iteration due to scattered memory allocation.</td>
        </tr>
        <tr>
          <td><b>Use Case</b></td>
          <td>Best suited for scenarios where frequent access and less modification of elements are required.</td>
          <td>Best suited for scenarios where frequent insertions and deletions are needed.</td>
        </tr>
        <tr>
          <td><b>Synchronization</b></td>
          <td>Not synchronized by default; must use <b>Collections.synchronizedList()</b> for thread-safety.</td>
          <td>Not synchronized by default; must use <b>Collections.synchronizedList()</b> for thread-safety.</td>
        </tr>
        <tr>
          <td><b>Performance</b></td>
          <td>Better performance for smaller lists or when accessing elements frequently by index.</td>
          <td>Better performance for larger lists or when frequent additions/removals are required.</td>
        </tr>
      </tbody>
    </table>
  
    <p><b>Summary:</b> Choose <b>ArrayList</b> for fast random access and <b>LinkedList</b> for efficient insertions and deletions.</p>
</div>
<hr>

<div id="cursor">
  <h5>What are cursors in Collection?</h5>
  <p>
    In Java, a cursor is an interface that provides a way to traverse or iterate over elements in a Collection.
  </p>
  <ol>
    <b>Java provides three types of cursors:</b>
    <li>Enumerator</li>
    <li>Iterator</li>
    <li>ListIterator</li>
  </ol>
</div>
<hr>

<div id="EnumItr">
    <h5>Difference Between Enumeration and Iterator</h5>
    <ul>
      <b>Enumeration:</b>
      <li>Introduced in Java 1.0</li>
      <li>Applicable for Legacy classes like Vector and Stack</li>
      <li>Only allows forword traversal</li>
      <li>Cannot modify elements during iteration.</li>
      <pre>
import java.util.*;

public class EnumerationExample {
    public static void main(String[] args) {
        Vector<Integer> vector = new Vector<>();
        vector.add(1);
        vector.add(2);
        vector.add(3);

        Enumeration<Integer> enumeration = vector.elements();
        while (enumeration.hasMoreElements()) {
            System.out.println(enumeration.nextElement());
        }
    }
}

      </pre>
    </ul>

    <ul>
      <b>Iterator:</b>
      <li>Introduced in: Java 1.2</li>
      <li>Applicable for: All Java Collection Framework classes (e.g., ArrayList, HashSet, LinkedList, etc.)</li>
      <li>Only allows forward traversal.</li>
      <li>Allows element removal during iteration using remove().</li>
      <li>Does not support element modification.</li>
      <pre>
import java.util.*;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if (fruit.equals("Banana")) {
                iterator.remove();  // Safe removal
            }
            System.out.println(fruit);
        }
        System.out.println("Final List: " + list);
    }
}

      </pre>
    </ul>
</div>
<hr>

<div id="ItrLItr">
    <h5>Difference Between Iterator and ListIterator:</h5>
    <table border="1" cellpadding="5" cellspacing="0">
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Iterator</th>
          <th>ListIterator</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><b>Introduction</b></td>
          <td>Introduced in Java 1.2 as part of the Collection Framework.</td>
          <td>Introduced in Java 1.2, specifically for working with <b>List</b> collections.</td>
        </tr>
        <tr>
          <td><b>Applicability</b></td>
          <td>Can be used to traverse any <b>Collection</b>.</td>
          <td>Can only be used to traverse <b>List</b> collections (e.g., <b>ArrayList</b>, <b>LinkedList</b>).</td>
        </tr>
        <tr>
          <td><b>Traversal Direction</b></td>
          <td>Supports only forward traversal.</td>
          <td>Supports both forward and backward traversal.</td>
        </tr>
        <tr>
          <td><b>Element Access</b></td>
          <td>Can retrieve elements using the <b>next()</b> method.</td>
          <td>Can retrieve elements using <b>next()</b> (forward) and <b>previous()</b> (backward).</td>
        </tr>
        <tr>
          <td><b>Element Modification</b></td>
          <td>Allows element removal using the <b>remove()</b> method.</td>
          <td>Allows addition, modification, and removal of elements using <b>add()</b>, <b>set()</b>, and <b>remove()</b> methods.</td>
        </tr>
        <tr>
          <td><b>Position Information</b></td>
          <td>Does not provide information about the current position of the iterator.</td>
          <td>Provides methods like <b>nextIndex()</b> and <b>previousIndex()</b> to get the current position.</td>
        </tr>
        <tr>
          <td><b>Preferred Use</b></td>
          <td>Use for general collection traversal.</td>
          <td>Use when working specifically with lists and bidirectional traversal or modification is needed.</td>
        </tr>
      </tbody>
    </table>
  
    <p><b>Example for Iterator:</b></p>
    <pre>
  import java.util.*;
  
  public class IteratorExample {
      public static void main(String[] args) {
          List<String> list = new ArrayList<>(Arrays.asList("Java", "Python", "C++"));
          Iterator<String> iterator = list.iterator();
          
          while (iterator.hasNext()) {
              System.out.println(iterator.next());
          }
      }
  }
    </pre>
  
    <p><b>Example for ListIterator:</b></p>
    <pre>
  import java.util.*;
  
  public class ListIteratorExample {
      public static void main(String[] args) {
          List<String> list = new ArrayList<>(Arrays.asList("Java", "Python", "C++"));
          ListIterator<String> listIterator = list.listIterator();
          
          System.out.println("Forward Traversal:");
          while (listIterator.hasNext()) {
              System.out.println(listIterator.next());
          }
  
          System.out.println("Backward Traversal:");
          while (listIterator.hasPrevious()) {
              System.out.println(listIterator.previous());
          }
      }
  }
    </pre>
</div>
<hr>

<div id="FFastFSafe">
  <h5>What is the difference between fail-fast and fail-safe iterators?</h5>
  <p>
    In Java, iterators can be categorized as Fail-Fast and Fail-Safe, depending on how they handle concurrent modifications during iteration.
  </p>
  <ul>
    <li><b>Fail-Fast Iterator:</b></li>
    <ul>
        <li>Throws <b><b>ConcurrentModificationException</b></b> if the collection is modified during iteration.</li>
        <li>Works directly on the original collection, detecting structural changes.</li>
        <li>Examples: Iterators of <b>ArrayList</b>, <b>LinkedList</b>, <b>HashSet</b>, <b>HashMap</b>, <b>LinkedHashMap</b> etc.</li>
        <li>Faster performance due to working directly on the collection.</li>
        <li>Should be used when thread-safety is not a concern.</li>
        <pre>
import java.util.*;

public class FailFastExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("One");
        list.add("Two");
        list.add("Three");

        Iterator<String> iterator = list.iterator();
        
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
            list.add("Four");  // Modifying collection during iteration
        }
    }
}
        </pre>
        <li><b>How to avoid it?</b> : Use <b>Iterator.remove()</b> instead of <b>list.remove()</b></li>
        <pre>
          Iterator<String> iterator = list.iterator();
            while (iterator.hasNext()) {
                String item = iterator.next();
                if (item.equals("Two")) {
                    iterator.remove();  // Allowed, won't throw exception
                }
            }
            
        </pre>
    </ul>

    <li><b>Fail-Safe Iterator:</b></li>
    <ul>
        <li>Does not throw <b>ConcurrentModificationException</b> if the collection is modified during iteration.</li>
        <li>Works on a cloned copy of the collection, ensuring modifications do not affect iteration.</li>
        <li>Examples: Iterators of <b>CopyOnWriteArrayList</b>, <b>CopyOnWriteArraySet</b>, <b>ConcurrentHashMap</b>.</li>
        <li>Consumes more memory due to creating a separate copy.</li>
        <li>Useful in concurrent environments where modifications are frequent.</li>
        <pre>
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Iterator;

public class FailSafeExample {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        list.add("One");
        list.add("Two");
        list.add("Three");

        Iterator<String> iterator = list.iterator();
        
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
            list.add("Four");  // Allowed in Fail-Safe Iterators
        }
    }
}

        </pre>
    </ul>
  </ul>
</div>
<hr>

<div id="SI">
  <h5>Explain Set Interface</h5>
  <p>The <b>Set</b> interface is a subinterface of the <b>Collection</b> interface in the <b>java.util</b> package. It represents a collection that does not allow duplicate elements. A <b>Set</b> is primarily used when uniqueness is required, and it does not maintain any specific order of elements unless explicitly stated by its implementation.</p>

  <p><b>Hierarchy:</b></p>
  <ul>
    <li>The <b>Set</b> interface extends the <b>Collection</b> interface.</li>
    <li>Some common implementations of the <b>Set</b> interface are:
      <ul>
        <li><b>HashSet</b>: Implements a hash table to store elements and does not guarantee the order of elements.</li>
        <li><b>LinkedHashSet</b>: Extends <b>HashSet</b> and maintains the insertion order of elements.</li>
        <li><b>TreeSet</b>: Implements a balanced tree structure and maintains elements in their natural order or a custom order defined by a comparator.</li>
      </ul>
    </li>
  </ul>

  <p><b>Key Features of the Set Interface:</b></p>
  <ul>
    <li><b>No Duplicates:</b> Ensures that all elements in the collection are unique.</li>
    <li><b>Unordered:</b> Does not guarantee any specific order of elements (except for implementations like <b>LinkedHashSet</b> or <b>TreeSet</b>).</li>
  </ul>

  <p><b>Key Methods of the Set Interface:</b></p>
  <ul>
    <li><b>boolean add(E e)</b>: Adds the specified element to the set if it is not already present.</li>
    <li><b>boolean contains(Object o)</b>: Checks if the set contains the specified element.</li>
    <li><b>boolean remove(Object o)</b>: Removes the specified element from the set if it is present.</li>
    <li><b>int size()</b>: Returns the number of elements in the set.</li>
    <li><b>Iterator<E> iterator()</b>: Returns an iterator over the elements in the set.</li>
    <li><b>boolean isEmpty()</b>: Checks if the set is empty.</li>
    <li><b>void clear()</b>: Removes all elements from the set.</li>
  </ul>
</div>
<hr>

<div id="SSI">
  <h5>SortedSet Interface:</h5>
  <p>The <b>SortedSet</b> interface is a subinterface of the <b>Set</b> interface in the <b>java.util</b> package. It represents a set that maintains its elements in a sorted order. The sorting can be based on the natural order of elements (if the elements implement the <b>Comparable</b> interface) or a custom order defined by a <b>Comparator</b>.</p>

  <p><b>Hierarchy:</b></p>
  <ul>
    <li>The <b>SortedSet</b> interface extends the <b>Set</b> interface.</li>
    <li>The <b>TreeSet</b> class is a common implementation of the <b>SortedSet</b> interface.</li>
  </ul>

  <p><b>Key Features of the SortedSet Interface:</b></p>
  <ul>
    <li><b>Sorted Order:</b> Ensures that elements are sorted either in their natural order or based on a custom comparator.</li>
    <li><b>No Duplicates:</b> Ensures that all elements in the set are unique.</li>
  </ul>

  <p><b>Key Methods of the SortedSet Interface:</b></p>
  <ul>
    <li><b>E first()</b>: Returns the first (lowest) element in the set.</li>
    <li><b>E last()</b>: Returns the last (highest) element in the set.</li>
    <li><b>SortedSet<E> headSet(E toElement)</b>: Returns a view of the portion of the set whose elements are strictly less than the specified element.</li>
    <li><b>SortedSet<E> tailSet(E fromElement)</b>: Returns a view of the portion of the set whose elements are greater than or equal to the specified element.</li>
    <li><b>SortedSet<E> subSet(E fromElement, E toElement)</b>: Returns a view of the portion of the set whose elements range from <b>fromElement</b>, inclusive, to <b>toElement</b>, exclusive.</li>
    <li><b>Comparator&lt;? super E> comparator()</b>: Returns the comparator used to order the elements, or <b>null</b> if the set uses natural ordering.</li>
  </ul>

  <p><b>Common Implementation of the SortedSet Interface:</b></p>
  <ul>
    <li><b>TreeSet</b>: A balanced tree implementation of the <b>SortedSet</b> interface. It maintains the elements in a sorted order.</li>
  </ul>
</div>
<hr>

<div id="NI">
  <h5>NavigableSet Interface:</h5>
  <ul>
    <li>The NavigableSet interface in Java extends the SortedSet interface.</li>
    <li>It provides methods for navigating and retrieving elements based on closest matches.</li>
    <li>Introduced in Java 1.6</li>
    <li>Supports ascending and descending order iteration.</li>
    <li>Implements all methods of SortedSet (which extends Set).</li>
    <li>Available Implementations: TreeSet (most commonly used).</li>
    <li>Use : When you need navigation-based operations (lower(), ceiling(), higher(), etc.).</li>
  </ul>
</div>
<hr>

<div id="HSet">
    <h5>Explain HashSet Class</h5>
    <p>The <b>HashSet</b> class in <b>java.util</b> implements the <b>Set</b> interface and is backed by a hash table (actually a <b>HashMap</b> instance). It does not allow duplicate elements and does not maintain the insertion order of elements. The primary purpose of a <b>HashSet</b> is to provide a collection of unique elements and to allow fast retrieval.</p>
  
    <p><b>Key Features of HashSet:</b></p>
    <ul>
      <li><b>No Duplicates:</b> A <b>HashSet</b> does not allow duplicate elements. If you try to add a duplicate, the set remains unchanged.</li>
      <li><b>No Guaranteed Order:</b> The elements in a <b>HashSet</b> are unordered, meaning there is no guarantee of the order in which the elements are stored or retrieved.</li>
      <li><b>Performance:</b> Provides constant time performance for basic operations like add, remove, and contains (<b>O(1)</b> complexity) assuming the hash function distributes elements uniformly.</li>
      <li><b>Null Elements:</b> A <b>HashSet</b> allows a single <b>null</b> element, but more than one <b>null</b> is not allowed.</li>
      <li><b>Implements:</b> Implements the <b>Set</b>, <b>Cloneable</b>, <b>Serializable</b>, and <b>Iterable</b> interfaces.</li>
    </ul>
  
    <p><b>Key Methods:</b></p>
    <ul>
      <li><b>add(E e)</b>: Adds the specified element to the set if it is not already present.</li>
      <li><b>remove(Object o)</b>: Removes the specified element from the set.</li>
      <li><b>contains(Object o)</b>: Returns <b>true</b> if the set contains the specified element.</li>
      <li><b>size()</b>: Returns the number of elements in the set.</li>
      <li><b>clear()</b>: Removes all the elements from the set.</li>
      <li><b>isEmpty()</b>: Returns <b>true</b> if the set is empty.</li>
    </ul>
  
    <p><b>Example Usage:</b></p>
    <pre>
  import java.util.*;
  
  public class HashSetExample {
      public static void main(String[] args) {
          // Creating a HashSet
          HashSet<String> set = new HashSet<>();
  
          // Adding elements to the HashSet
          set.add("Java");
          set.add("Python");
          set.add("C++");
          set.add("Java");  // Duplicate, will be ignored
  
          // Displaying the HashSet
          System.out.println("HashSet: " + set);
  
          // Checking if an element exists
          System.out.println("Contains 'Python': " + set.contains("Python"));
  
          // Removing an element
          set.remove("C++");
          System.out.println("After removing 'C++': " + set);
  
          // Checking size
          System.out.println("Size of HashSet: " + set.size());
      }
  }
    </pre>
</div>
<hr>

<div id="DHSLHSTS">
  <h5>What is the difference between <b>HashSet</b>, <b>LinkedHashSet</b>, and <b>TreeSet</b>?</h5>

<ul>
    <li><b>HashSet:</b></li>
    <ul>
        <li><b>HashSet</b> is an unordered collection that does not guarantee the order of elements.</li>
        <li>It uses a hash table for storing elements and ensures uniqueness of elements using the hash code and equals() methods.</li>
        <li>It provides O(1) time complexity for basic operations like add, remove, and contains, assuming a good hash function.</li>
    </ul>

    <li><b>LinkedHashSet:</b></li>
    <ul>
        <li><b>LinkedHashSet</b> is an ordered version of the <b>HashSet</b>. It maintains the insertion order of elements.</li>
        <li>Internally, it uses a hash table along with a linked list to maintain the order of elements.</li>
        <li>It ensures uniqueness of elements like <b>HashSet</b>, but also maintains the order of insertion.</li>
        <li>Operations like add, remove, and contains take O(1) time on average, but maintaining order adds a slight overhead compared to <b>HashSet</b>.</li>
    </ul>

    <li><b>TreeSet:</b></li>
    <ul>
        <li><b>TreeSet</b> is a sorted set that stores elements in their natural order or based on a custom comparator.</li>
        <li>It uses a Red-Black tree to store elements, which ensures that the set is always sorted.</li>
        <li>While it guarantees uniqueness, it does not allow elements to be stored in arbitrary order, unlike <b>HashSet</b> or <b>LinkedHashSet</b>.</li>
        <li>Basic operations like add, remove, and contains take O(log n) time due to the underlying tree structure.</li>
    </ul>

    <li><b>Summary of Key Differences:</b></li>
    <ul>
        <li><b>Order:</b>
            <ul>
                <li><b>HashSet</b>: No guaranteed order.</li>
                <li><b>LinkedHashSet</b>: Maintains insertion order.</li>
                <li><b>TreeSet</b>: Stores elements in sorted order (either natural or using a comparator).</li>
            </ul>
        </li>
        
        <li><b>Performance:</b>
            <ul>
                <li><b>HashSet</b>: O(1) for add, remove, contains.</li>
                <li><b>LinkedHashSet</b>: O(1) for add, remove, contains (with slight overhead for maintaining order).</li>
                <li><b>TreeSet</b>: O(log n) for add, remove, contains due to the tree structure.</li>
            </ul>
        </li>

        <li><b>Use Case:</b>
            <ul>
                <li><b>HashSet</b>: Use when you only care about uniqueness and do not need order.</li>
                <li><b>LinkedHashSet</b>: Use when you care about both uniqueness and maintaining the order of insertion.</li>
                <li><b>TreeSet</b>: Use when you need to store elements in a sorted order and care about efficient searching and navigation.</li>
            </ul>
        </li>
    </ul>
</ul>

</div>
<hr>

<div id="HSNull">
  
<h5>Why does <b>HashSet</b> allow only one null value?</h5>

<ul>
    <li><b>HashSet stores elements using a hash table:</b></li>
    <ul>
        <li><b>HashSet</b> uses a hash table (backed by a <b>HashMap</b>) to store its elements.</li>
        <li>In the hash table, the uniqueness of elements is determined by their hash code and equals() method.</li>
    </ul>

    <li><b>Hash code of null:</b></li>
    <ul>
        <li>The null value has a unique behavior in the context of hash tables.</li>
        <li><b>null</b> has a hash code of 0, and the `equals()` method is not called for <b>null</b> (because it is never equal to any other object).</li>
        <li>This ensures that only one <b>null</b> can exist in the set, since all `null` elements would have the same hash code, and adding a second <b>null</b> would violate the uniqueness property of the set.</li>
    </ul>

    <li><b>Why only one null?</b></li>
    <ul>
        <li>Since the hash code of <b>null</b> is always 0, it will always map to the same bucket in the hash table.</li>
        <li>Even if you try to insert another <b>null</b> value, it will clash with the existing <b>null</b> value because they have the same hash code, leading to the rejection of the duplicate.</li>
        <li>Thus, only one <b>null</b> value can be stored in a <b>HashSet</b> to maintain the set's property of uniqueness.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HSUniq">
  <h5>How does <b>HashSet</b> maintain uniqueness?</h5>

<ul>
    <li><b>Underlying Data Structure:</b></li>
    <ul>
        <li><b>HashSet</b> internally uses a hash table (backed by a <b>HashMap</b>) to store its elements.</li>
        <li>Each element in the <b>HashSet</b> is stored as a key in the hash table, and the values are dummy placeholders (often <b>Boolean.TRUE</b>).</li>
    </ul>

    <li><b>Uniqueness Mechanism:</b></li>
    <ul>
        <li>When an element is added to a <b>HashSet</b>, the set checks if the element already exists based on its hash code and equals() method.</li>
        <li>If the element’s hash code matches an existing element’s hash code, <b>equals()</b> is used to compare the elements for equality.</li>
        <li>If the element is equal to an existing element (i.e., both hash code and <b>equals()</b> comparison return true), it is not added to the set.</li>
        <li>This guarantees that only unique elements are stored in the set.</li>
    </ul>

    <li><b>Hash Code and Equals:</b></li>
    <ul>
        <li><b>HashSet</b> relies on the correct implementation of the <b>hashCode()</b> and <b>equals()</b> methods of the objects being stored.</li>
        <li>If two objects have the same hash code but are not equal, they may still be stored as separate entries (but this is inefficient).</li>
    </ul>

    <li><b>Example:</b></li>
    <pre>
        HashSet<String> set = new HashSet&lt;&gt;();
        set.add("A");
        set.add("B");
        set.add("A"); // Duplicate, won't be added

        System.out.println(set); // Output: [A, B]
    </pre>
    
    <li><b>Advantages:</b></li>
    <ul>
        <li><b>HashSet</b> provides constant time complexity (O(1)) for basic operations like add, remove, and contains, assuming a good hash function.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HSDup">
    <h5>What Happens When You Try to Insert Duplicate Values in a Set?</h5>
    <ul>
      <li>When you attempt to add an element that already exists in the set, the <b>add()</b> method will return <b>false</b>, indicating that the element was not added because it was already present.</li>
      <li>The internal structure of the set ensures that only unique elements are stored.</li>
      <li>This behavior is consistent across different types of sets, such as <b>HashSet</b>, <b>LinkedHashSet</b>, and <b>TreeSet</b>.</li>
    </ul>
</div>
<hr>

<div id="LHS">
    <h5>LinkedHashSet Class:</h5>
    <p>The <b>LinkedHashSet</b> class in Java is part of the <b>java.util</b> package and extends the <b>HashSet</b> class. It implements the <b>Set</b> interface and is backed by a hash table (like <b>HashSet</b>) and a linked list that maintains the insertion order of elements. This means that in a <b>LinkedHashSet</b>, the elements are stored in the order in which they were added.</p>
  
    <p><b>Key Features of LinkedHashSet:</b></p>
    <ul>
      <li><b>Insertion Order:</b> Unlike <b>HashSet</b>, which does not guarantee any specific order, <b>LinkedHashSet</b> maintains the order of insertion. Elements are retrieved in the order they were added.</li>
      <li><b>No Duplicates:</b> Like all sets, <b>LinkedHashSet</b> does not allow duplicate elements. It will ignore any attempt to add a duplicate element.</li>
      <li><b>Performance:</b> <b>LinkedHashSet</b> provides constant time performance for basic operations like <b>add()</b>, <b>remove()</b>, and <b>contains()</b>, similar to <b>HashSet</b>. However, it has some overhead due to maintaining the linked list for the order.</li>
      <li><b>Allows Null:</b> <b>LinkedHashSet</b> allows a single <b>null</b> element.</li>
      <li><b>Maintains Order of Insertion:</b> The main difference between <b>HashSet</b> and <b>LinkedHashSet</b> is that the latter maintains the order of insertion, meaning the elements are returned in the same order they were added to the set.</li>
    </ul>
  
    <p><b>Key Methods:</b></p>
    <ul>
      <li><b>add(E e)</b>: Adds the specified element to the set if it is not already present.</li>
      <li><b>remove(Object o)</b>: Removes the specified element from the set.</li>
      <li><b>contains(Object o)</b>: Returns <b>true</b> if the set contains the specified element.</li>
      <li><b>size()</b>: Returns the number of elements in the set.</li>
      <li><b>clear()</b>: Removes all elements from the set.</li>
      <li><b>isEmpty()</b>: Returns <b>true</b> if the set is empty.</li>
    </ul>
  
    <p><b>Example Usage:</b></p>
    <pre>
  import java.util.*;
  
  public class LinkedHashSetExample {
      public static void main(String[] args) {
          // Creating a LinkedHashSet
          LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();
          
          // Adding elements
          linkedHashSet.add("Java");
          linkedHashSet.add("Python");
          linkedHashSet.add("C++");
          linkedHashSet.add("Java");  // Duplicate, will be ignored
          
          // Displaying the LinkedHashSet
          System.out.println("LinkedHashSet: " + linkedHashSet);
  
          // Checking if an element exists
          System.out.println("Contains 'Python': " + linkedHashSet.contains("Python"));
  
          // Removing an element
          linkedHashSet.remove("C++");
          System.out.println("After removing 'C++': " + linkedHashSet);
      }
  }
  <b>Output:</b>
  LinkedHashSet: [Java, Python, C++]
  Contains 'Python': true
  After removing 'C++': [Java, Python]
    </pre>
  
</div>
<hr>

<div id="TS">
    <h5>Explain TreeSet Class</h5>
    <p>The <b>TreeSet</b> class in Java is part of the <b>java.util</b> package and implements the <b>Set</b> interface. It is backed by a <b>TreeMap</b> and stores elements in a sorted order. Unlike other set implementations like <b>HashSet</b> or <b>LinkedHashSet</b>, which do not guarantee order, a <b>TreeSet</b> automatically arranges its elements according to their natural ordering or by a comparator provided at the time of set creation.</p>
  
    <p><b>Key Features of TreeSet:</b></p>
    <ul>
      <li><b>Sorted Order:</b> Elements in a <b>TreeSet</b> are stored in ascending order by default. If the elements are comparable, they are sorted based on their natural ordering. If not, a custom comparator can be provided.</li>
      <li><b>No Duplicates:</b> Like other <b>Set</b> implementations, <b>TreeSet</b> does not allow duplicate elements.</li>
      <li><b>Performance:</b> The basic operations like <b>add()</b>, <b>remove()</b>, and <b>contains()</b> have a time complexity of <b>O(log n)</b> because the underlying data structure is a balanced tree.</li>
      <li><b>Null Elements:</b> <b>TreeSet</b> does not allow <b>null</b> elements if the set uses natural ordering. This is because <b>null</b> cannot be compared with other elements in the set.</li>
      <li><b>Implements:</b> <b>TreeSet</b> implements the <b>Set</b>, <b>NavigableSet</b>, and <b>Cloneable</b> interfaces.</li>
    </ul>
  
    <p><b>Key Methods:</b></p>
    <ul>
      <li><b>add(E e)</b>: Adds the specified element to the set if it is not already present, and returns <b>true</b>. If the element is already present, it returns <b>false</b>.</li>
      <li><b>remove(Object o)</b>: Removes the specified element from the set.</li>
      <li><b>first()</b>: Returns the first (lowest) element in the set.</li>
      <li><b>last()</b>: Returns the last (highest) element in the set.</li>
      <li><b>ceiling(E e)</b>: Returns the least element in the set greater than or equal to the specified element.</li>
      <li><b>floor(E e)</b>: Returns the greatest element in the set less than or equal to the specified element.</li>
    </ul>
  
    <p><b>Example Usage:</b></p>
    <pre>
  import java.util.*;
  
  public class TreeSetExample {
      public static void main(String[] args) {
          // Creating a TreeSet
          TreeSet<Integer> treeSet = new TreeSet<>();
          
          // Adding elements
          treeSet.add(10);
          treeSet.add(20);
          treeSet.add(15);
          treeSet.add(30);
          treeSet.add(20);  // Duplicate, will be ignored
          
          // Displaying the TreeSet
          System.out.println("TreeSet: " + treeSet);
  
          // Finding the first and last elements
          System.out.println("First Element: " + treeSet.first());
          System.out.println("Last Element: " + treeSet.last());
      }
  }
  <b>Output:</b>
  TreeSet: [10, 15, 20, 30]
  First Element: 10
  Last Element: 30

    </pre>
</div>
<hr>

<div id="TSO">
  
<h5>How does <b>TreeSet</b> maintain sorting order?</h5>

<ul>
    <li><b>Internal Data Structure:</b></li>
    <ul>
        <li><b>TreeSet</b> is backed by a <b>Red-Black tree</b>, which is a self-balancing binary search tree.</li>
        <li>The elements in a <b>TreeSet</b> are stored in the tree nodes in such a way that the tree remains balanced, ensuring efficient access and insertion.</li>
    </ul>

    <li><b>Sorting Mechanism:</b></li>
    <ul>
        <li><b>TreeSet</b> sorts its elements using their <b>natural order</b> (i.e., the order defined by the <b>Comparable</b> interface).</li>
        <li>If the elements implement the <b>Comparable</b> interface, the <b>compareTo()</b> method is used to determine the sorting order.</li>
        <li>For objects that do not implement <b>Comparable</b>, you can provide a custom sorting order via a <b>Comparator</b>.</li>
        <li>The Red-Black tree ensures that elements are always inserted in sorted order, and this sorting is maintained with each operation, including insertions, deletions, and lookups.</li>
    </ul>

    <li><b>Example of Natural Ordering:</b></li>
    <pre>
        TreeSet<Integer> set = new TreeSet&lt;&gt;();
        set.add(5);
        set.add(1);
        set.add(3);
        set.add(2);

        System.out.println(set); // Output: [1, 2, 3, 5]
    </pre>

    <li><b>Custom Ordering (using Comparator):</b></li>
    <ul>
        <li>If a custom sorting order is required, a <b>Comparator</b> can be provided to the <b>TreeSet</b>.</li>
        <li>In this case, the <b>Comparator</b> will define the sorting rules for the elements.</li>
    </ul>
    <pre>
        TreeSet<Integer> set = new TreeSet&lt;&gt;(Comparator.reverseOrder());
        set.add(5);
        set.add(1);
        set.add(3);
        set.add(2);

        System.out.println(set); // Output: [5, 3, 2, 1]
    </pre>

    <li><b>Performance:</b></li>
    <ul>
        <li>Because of the underlying Red-Black tree structure, operations like add, remove, and contains are <b>O(log n)</b> in time complexity.</li>
        <li>Maintaining the sorted order ensures that the set remains efficient for searching and iteration.</li>
    </ul>

    <li><b>Use Case:</b></li>
    <ul>
        <li><b>TreeSet</b> is ideal when you need to store unique elements that are sorted automatically, either in their natural order or using a custom comparator.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HSVSTS">
  <h5>Why is <b>HashSet</b> faster than <b>TreeSet</b>?</h5>

<ul>
    <li><b>Internal Data Structure:</b></li>
    <ul>
        <li><b>HashSet</b> is backed by a <b>hash table</b> (or a hash map), which provides fast access to elements using a hash code.</li>
        <li><b>TreeSet</b> is backed by a <b>Red-Black tree</b>, a self-balancing binary search tree, which has a more complex structure for maintaining sorting order.</li>
    </ul>

    <li><b>Performance of Basic Operations:</b></li>
    <ul>
        <li>In <b>HashSet</b>, operations like <b>add</b>, <b>remove</b>, and <b>contains</b> typically have an average time complexity of <b>O(1)</b>, assuming a good hash function and low collision rates.</li>
        <li>In <b>TreeSet</b>, the operations like <b>add</b>, <b>remove</b>, and <b>contains</b> take <b>O(log n)</b> time due to the underlying Red-Black tree structure, which maintains sorted order at all times.</li>
    </ul>

    <li><b>Sorting Overhead in TreeSet:</b></li>
    <ul>
        <li><b>TreeSet</b> maintains elements in a sorted order (either natural or custom sorting via a comparator), which requires extra effort during every insertion and deletion.</li>
        <li>This sorting adds additional overhead because the tree structure needs to maintain balance after each modification (insertion or deletion) to ensure efficient searching and iteration.</li>
    </ul>

    <li><b>Cost of Comparison:</b></li>
    <ul>
        <li>In a <b>TreeSet</b>, elements are compared during insertion and lookup to maintain the sorting order. This comparison is generally <b>O(log n)</b> in time complexity, depending on the number of nodes in the tree.</li>
        <li>In a <b>HashSet</b>, no comparisons are required for basic operations. Instead, elements are directly inserted or searched using their hash codes, which is faster than maintaining order.</li>
    </ul>

    <li><b>Use Case Differences:</b></li>
    <ul>
        <li><b>HashSet</b> is preferred when you need fast operations for storing and accessing unique elements without caring about order.</li>
        <li><b>TreeSet</b> is used when you need sorted elements and are willing to sacrifice some performance for automatic sorting of data.</li>
    </ul>

    <li><b>Summary of Key Differences:</b></li>
    <ul>
        <li><b>HashSet</b>: Faster for <b>basic operations</b> (add, remove, contains) due to its <b>O(1)</b> time complexity (average case).</li>
        <li><b>TreeSet</b>: Slower for <b>basic operations</b> due to the need to maintain <b>sorted order</b> and <b>balance</b> the tree, with time complexity of <b>O(log n)</b>.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HSScenario">
  <h5>In an <b>authentication system</b>, you need to store <b>unique user session tokens</b> efficiently. Which Set implementation is best?</h5>

<ul>
    <li><b>Best Set Implementation: <b>HashSet</b></b></li>
    <ul>
        <li><b>HashSet</b> is the best choice when you need to store unique elements (such as session tokens) with fast access and insertion.</li>
        <li>It uses a hash table internally, which provides constant time complexity (average O(1)) for basic operations like add, remove, and contains.</li>
    </ul>

    <li><b>Why <b>HashSet</b> is Ideal for Session Tokens:</b></li>
    <ul>
        <li>Efficiency: Since session tokens are typically unique and need to be checked frequently for existence or removed after the session expires, <b>HashSet</b> is efficient because it doesn't require comparisons or sorting.</li>
        <li>No Ordering Required: In this case, the order of session tokens does not matter, and <b>HashSet</b> allows for fast access without maintaining any order, unlike <b>TreeSet</b>, which sorts the elements.</li>
        <li>Handling Duplicates: Since <b>HashSet</b> ensures uniqueness, you won't have to worry about storing duplicate session tokens.</li>
    </ul>

    <li><b>Why Not Other Set Implementations?</b></li>
    <ul>
        <li><b><b>TreeSet</b></b>: Although it ensures uniqueness, it maintains elements in a sorted order. The sorting overhead and the fact that session tokens don't need to be sorted makes it less efficient for this use case compared to <b>HashSet</b>.</li>
        <li><b><b>LinkedHashSet</b></b>: While it maintains insertion order, the extra overhead for maintaining the order makes it unnecessary for the use case of storing unique session tokens when the order is irrelevant.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>HashSet</b> is the optimal choice for storing unique user session tokens efficiently in terms of time complexity and memory usage.</li>
    </ul>
</ul>

</div>
<hr>

<div id="MI">
  <h5>Map Interface:</h5>
  <p>The <b>Map</b> interface is part of the <b>java.util</b> package and represents a collection of key-value pairs, where each key is unique, and each key maps to exactly one value. It is not a subtype of <b>Collection</b> but provides methods to store, retrieve, and manipulate key-value mappings.</p>

  <p><b>Key Features of the Map Interface:</b></p>
  <ul>
    <li><b>Key-Value Pairs:</b> A <b>Map</b> stores entries, where each entry consists of a key and a value.</li>
    <li><b>Unique Keys:</b> Every key in the map is unique, but the values associated with keys can be duplicate.</li>
    <li><b>Methods:</b> Common methods include <b>put()</b> to add mappings, <b>get()</b> to retrieve values, and <b>remove()</b> to delete mappings.</li>
  </ul>
  <pre>
      import java.util.*;
      
      public class MapExample {
          public static void main(String[] args) {
              Map<String, Integer> map = new HashMap&lt;&gt;;
      
              // Adding key-value pairs
              map.put("Java", 10);
              map.put("Python", 15);
              map.put("C++", 12);
      
              // Retrieving a value using a key
              System.out.println("Java: " + map.get("Java"));
      
              // Checking if a key exists
              System.out.println("Contains 'Python': " + map.containsKey("Python"));
      
              // Iterating over keys and values
              for (Map.Entry<String, Integer> entry : map.entrySet()) {
                  System.out.println(entry.getKey() + ": " + entry.getValue());
              }
          }
      }
      <b>Output:</b>
      Java: 10
      Contains 'Python': true
      Java: 10
      Python: 15
      C++: 12
        </pre>

  <p><b>Common Implementations of the Map Interface:</b></p>
  <ul>
    <li><b>HashMap</b>: A widely used implementation that stores elements based on the hash of the keys, offering constant time performance for basic operations.</li>
    <li><b>TreeMap</b>: A sorted map implementation that orders the keys according to their natural order or a custom comparator.</li>
    <li><b>LinkedHashMap</b>: An implementation that maintains the order of insertion of the keys.</li>
    <li><b>Hashtable</b>: An older, synchronized implementation (replaced by <b>ConcurrentHashMap</b> in modern applications for thread-safety).</li>
  </ul>
</div>
<hr>

<div id="SMI">
  <h5>Explain SortedMap Interface</h5>
  <p>The <b>SortedMap</b> interface is a subinterface of the <b>Map</b> interface in the <b>java.util</b> package. It represents a map that maintains its keys in a sorted order, either in their natural order or according to a custom comparator provided at the time of map creation. The elements in a <b>SortedMap</b> are ordered based on the keys, and it provides additional methods to deal with ranges of keys.</p>

  <p><b>Key Features of the SortedMap Interface:</b></p>
  <ul>
    <li><b>Sorted Keys:</b> The keys are always stored in a sorted order (either natural or based on a <b>Comparator</b>).</li>
    <li><b>Additional Range Methods:</b> It provides methods to view submaps, headmaps, and tailmaps based on a specific key range.</li>
    <li><b>Methods:</b> Methods like <b>firstKey()</b>, <b>lastKey()</b>, <b>headMap()</b>, and <b>tailMap()</b> help with navigating through the map's sorted keys.</li>
  </ul>

  <p><b>Common Implementation of the SortedMap Interface:</b></p>
  <ul>
    <li><b>TreeMap</b>: The most common implementation of the <b>SortedMap</b> interface, which stores key-value pairs in a red-black tree structure and ensures that keys are kept in sorted order.</li>
  </ul>

  <p><b>Key Methods of the SortedMap Interface:</b></p>
  <ul>
    <li><b>K firstKey()</b>: Returns the first (lowest) key in the map.</li>
    <li><b>K lastKey()</b>: Returns the last (highest) key in the map.</li>
    <li><b>SortedMap<K,V> headMap(K toKey)</b>: Returns a view of the portion of the map whose keys are less than the specified key.</li>
    <li><b>SortedMap<K,V> tailMap(K fromKey)</b>: Returns a view of the portion of the map whose keys are greater than or equal to the specified key.</li>
    <li><b>SortedMap<K,V> subMap(K fromKey, K toKey)</b>: Returns a view of the portion of the map whose keys are between <b>fromKey</b> (inclusive) and <b>toKey</b> (exclusive).</li>
  </ul>
  <p><b>Example Usage:</b></p>
<pre>
import java.util.*;

public class SortedMapExample {
  public static void main(String[] args) {
      SortedMap<String, Integer> sortedMap = new TreeMap<>();

      // Adding key-value pairs
      sortedMap.put("Java", 10);
      sortedMap.put("Python", 15);
      sortedMap.put("C++", 12);
      sortedMap.put("JavaScript", 18);

      // Displaying the sorted map
      System.out.println("SortedMap: " + sortedMap);

      // Accessing the first and last keys
      System.out.println("First Key: " + sortedMap.firstKey());
      System.out.println("Last Key: " + sortedMap.lastKey());

      // Submaps
      System.out.println("HeadMap (less than 'JavaScript'): " + sortedMap.headMap("JavaScript"));
      System.out.println("TailMap (greater than or equal to 'C++'): " + sortedMap.tailMap("C++"));
      System.out.println("SubMap (from 'Java' to 'Python'): " + sortedMap.subMap("Java", "Python"));
  }
}
<b>Output:</b>
SortedMap: {C++=12, Java=10, JavaScript=18, Python=15}
First Key: C++
Last Key: Python
HeadMap (less than 'JavaScript'): {C++=12, Java=10}
TailMap (greater than or equal to 'C++'): {C++=12, Java=10, JavaScript=18, Python=15}
SubMap (from 'Java' to 'Python'): {Java=10, JavaScript=18}
</pre>
</div>
<hr>

<div id="NMI">
  <h5>Eplain NavigableMap Interface</h5>
  <p>The <b>NavigableMap</b> interface is a subinterface of <b>SortedMap</b> in the <b>java.util</b> package. It extends the functionality of <b>SortedMap</b> by providing navigation methods for retrieving entries based on their proximity to a given key. It supports bidirectional traversal and allows precise control over subsets of the map.</p>

  <p><b>Key Features of NavigableMap:</b></p>
  <ul>
    <li><b>Proximity Navigation:</b> Methods like <b>lowerKey()</b>, <b>floorKey()</b>, <b>ceilingKey()</b>, and <b>higherKey()</b> help in finding keys near a specified key.</li>
    <li><b>Reverse Order:</b> The <b>descendingMap()</b> method provides a view of the map in reverse order.</li>
    <li><b>Subset Views:</b> Allows creation of subsets with precise control over inclusion/exclusion of boundary keys using <b>subMap()</b>, <b>headMap()</b>, and <b>tailMap()</b>.</li>
    <li><b>Polling Operations:</b> Methods like <b>pollFirstEntry()</b> and <b>pollLastEntry()</b> allow retrieval and removal of the first or last entry.</li>
  </ul>

  <p><b>Common Implementation:</b></p>
  <ul>
    <li><b>TreeMap</b>: The most common implementation of <b>NavigableMap</b>, which maintains key-value pairs in a red-black tree structure and provides navigation methods.</li>
  </ul>

  <p><b>Key Methods of NavigableMap:</b></p>
  <ul>
    <li><b>K lowerKey(K key)</b>: Returns the greatest key strictly less than the specified key.</li>
    <li><b>K floorKey(K key)</b>: Returns the greatest key less than or equal to the specified key.</li>
    <li><b>K ceilingKey(K key)</b>: Returns the smallest key greater than or equal to the specified key.</li>
    <li><b>K higherKey(K key)</b>: Returns the smallest key strictly greater than the specified key.</li>
    <li><b>NavigableMap<K,V> descendingMap()</b>: Returns a map with the keys in reverse order.</li>
    <li><b>Map.Entry<K,V> pollFirstEntry()</b>: Retrieves and removes the first entry in the map.</li>
    <li><b>Map.Entry<K,V> pollLastEntry()</b>: Retrieves and removes the last entry in the map.</li>
  </ul>

  <p><b>Example Usage:</b></p>
  <pre>
import java.util.*;

public class NavigableMapExample {
    public static void main(String[] args) {
        NavigableMap<String, Integer> navigableMap = new TreeMap<>();

        // Adding key-value pairs
        navigableMap.put("Java", 10);
        navigableMap.put("Python", 15);
        navigableMap.put("C++", 12);
        navigableMap.put("JavaScript", 18);

        // Displaying the map
        System.out.println("NavigableMap: " + navigableMap);

        // Navigation operations
        System.out.println("Lower Key (less than 'Python'): " + navigableMap.lowerKey("Python"));
        System.out.println("Floor Key (less than or equal to 'Python'): " + navigableMap.floorKey("Python"));
        System.out.println("Ceiling Key (greater than or equal to 'C++'): " + navigableMap.ceilingKey("C++"));
        System.out.println("Higher Key (greater than 'Java'): " + navigableMap.higherKey("Java"));

        // Reverse order view
        System.out.println("Descending Map: " + navigableMap.descendingMap());

        // Polling operations
        System.out.println("Poll First Entry: " + navigableMap.pollFirstEntry());
        System.out.println("Poll Last Entry: " + navigableMap.pollLastEntry());
        System.out.println("Map after polling: " + navigableMap);
    }
}
<b>Output:</b>
NavigableMap: {C++=12, Java=10, JavaScript=18, Python=15}
Lower Key (less than 'Python'): JavaScript
Floor Key (less than or equal to 'Python'): Python
Ceiling Key (greater than or equal to 'C++'): C++
Higher Key (greater than 'Java'): JavaScript
Descending Map: {Python=15, JavaScript=18, Java=10, C++=12}
Poll First Entry: C++=12
Poll Last Entry: Python=15
Map after polling: {Java=10, JavaScript=18}
  </pre>
</div>
<hr>

<div id="RAI">
  <h5>Explain RandomAccess Interface</h5>
  <p>The <b>RandomAccess</b> interface is a marker interface in the <b>java.util</b> package. It is used to indicate that a <b>List</b> implementation supports fast (constant time) random access to its elements. This interface helps optimize operations for data structures where direct access by index is efficient.</p>

  <p><b>Key Features of RandomAccess Interface:</b></p>
  <ul>
    <li><b>Marker Interface:</b> It does not define any methods. Its purpose is to serve as a tagging mechanism.</li>
    <li><b>Improves Performance:</b> Algorithms can check for this interface to use more efficient access methods when working with lists that support random access.</li>
    <li><b>Common Implementations:</b> The <b>ArrayList</b> and <b>Vector</b> classes implement this interface because they allow fast, index-based access to their elements.</li>
  </ul>

  <p><b>Usage:</b> When iterating over a list, checking whether it implements <b>RandomAccess</b> can help choose between <b>for</b>-loop (for index-based access) and iterator-based traversal for better performance.</p>

  <p><b>Example:</b></p>
  <pre>
import java.util.*;

public class RandomAccessExample {
    public static void main(String[] args) {
        List<String> arrayList = new ArrayList<>();
        List<String> linkedList = new LinkedList<>();

        // Adding elements
        arrayList.add("Java");
        arrayList.add("Python");
        linkedList.add("Java");
        linkedList.add("Python");

        // Check if the list supports RandomAccess
        System.out.println("Is ArrayList RandomAccess? " + (arrayList instanceof RandomAccess));
        System.out.println("Is LinkedList RandomAccess? " + (linkedList instanceof RandomAccess));

        // Optimized iteration
        if (arrayList instanceof RandomAccess) {
            System.out.println("Iterating ArrayList using for-loop:");
            for (int i = 0; i < arrayList.size(); i++) {
                System.out.println(arrayList.get(i));
            }
        } else {
            System.out.println("Iterating ArrayList using iterator:");
            for (String s : arrayList) {
                System.out.println(s);
            }
        }
    }
}
  </pre>

  <p><b>Advantages:</b></p>
  <ul>
    <li>Helps in optimizing performance by identifying lists that support fast random access.</li>
    <li>Improves efficiency of algorithms by choosing appropriate access methods.</li>
  </ul>

  <p><b>Common Implementations:</b> <b>ArrayList</b>, <b>Vector</b></p>
  <p><b>Non-Implementations:</b> <b>LinkedList</b> does not implement <b>RandomAccess</b> because it is designed for sequential access.</p>
</div>
<hr>

<div id="DHMLHM">
  <h5>What are the differences between <b>HashMap</b>, <b>LinkedHashMap</b>, and <b>TreeMap</b>?</h5>

<ul>
    <li><b>HashMap</b>:</li>
    <ul>
        <li><b>Internal Data Structure:</b> Uses a <b>hash table</b> to store key-value pairs.</li>
        <li><b>Order:</b> Does not maintain any order of the keys or values. The order is not predictable.</li>
        <li><b>Performance:</b> Provides constant time complexity, <b>O(1)</b> for <b>get</b> and <b>put</b> operations, on average (assuming a good hash function).</li>
        <li><b>Null Keys and Values:</b> Allows one <b>null</b> key and multiple <b>null</b> values.</li>
    </ul>

    <li><b>LinkedHashMap</b>:</li>
    <ul>
        <li><b>Internal Data Structure:</b> Uses a <b>hash table</b> like <b>HashMap</b>, but it maintains a linked list of the entries to preserve insertion order.</li>
        <li><b>Order:</b> Maintains the insertion order of keys (or access order if specified during construction).</li>
        <li><b>Performance:</b> Slightly slower than <b>HashMap</b> because of the overhead of maintaining the order. However, its <b>get</b> and <b>put</b> operations are still <b>O(1)</b>.</li>
        <li><b>Null Keys and Values:</b> Similar to <b>HashMap</b>, allows one <b>null</b> key and multiple <b>null</b> values.</li>
    </ul>

    <li><b>TreeMap</b>:</li>
    <ul>
        <li><b>Internal Data Structure:</b> Uses a Red-Black tree (a balanced binary search tree) to store key-value pairs.</li>
        <li><b>Order:</b> Maintains the keys in <b>sorted order</b> based on their natural ordering or according to a <b>Comparator</b> provided at the time of creation.</li>
        <li><b>Performance:</b> Provides <b>O(log n)</b> time complexity for <b>get</b> and <b>put</b> operations due to the underlying tree structure.</li>
        <li><b>Null Keys and Values:</b> Does not allow <b>null</b> keys, but allows <b>null</b> values.</li>
    </ul>

    <li><b>Summary of Key Differences:</b></li>
    <ul>
        <li><b>HashMap:</b> Fast, no order, allows one <b>null</b> key.</li>
        <li><b>LinkedHashMap:</b> Maintains insertion order or access order, slightly slower than <b>HashMap</b>.</li>
        <li><b>TreeMap:</b> Maintains sorted order of keys, slower than both <b>HashMap</b> and <b>LinkedHashMap</b> due to <b>O(log n)</b> operations.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HMImpl">
  <h5>What is the <b>internal structure of HashMap</b> in Java 17?</h5>

<ul>
    <li><b>HashMap Internal Structure:</b></li>
    <ul>
        <li>HashMap in Java 17 is based on an array of buckets (an array of Entry objects) and hashing to store key-value pairs.</li>
        <li>Each bucket stores a linked list or a balanced tree structure (in case of hash collisions) that holds multiple entries for the same hash value.</li>
    </ul>
    <b>Example:</b>
    <ul>
      <li>HashMap Initialization: Default size = 16. </li>
          HashMap<Key, Integer> map = new HashMap&lt;&gt;();
          
  
      <li>Inserting Key-Value Pairs:</li>
          <ul>
            <li>Key: "vishal", Value: 20 → HashCode: 118, Index: 6 → Placed at index 6. </li>
            <li>Key: "sachin", Value: 30 → HashCode: 115, Index: 3 → Placed at index 3. </li>
            <li>Key: "vaibhav", Value: 40 → HashCode: 118, Index: 6 → Collision occurs, linked list formed at index 6.</li>
          </ul>
          
          <pre>
  map.put(new Key("vishal"), 20);
  <b>Create a node object as : </b>
  {
    int hash = 118
    // {"vishal"} is not a string but 
    // an object of class Key
    Key key = {"vishal"}
    Integer value = 20
    Node next = null
  }
          </pre>
          <img src="../../images/hashmap.PNG" class="responsive-image"><br>
  
      <li>Collision Handling:</li>
          <ul>
            <li>If two keys have the same index, HashMap uses a linked list (Java 8+ uses Tree after threshold). </li>
            <li>If keys are equal, update value. Else, link new node to the existing node.</li>
          </ul>
  
      <li>Retrieving Values (`get()` method):</li>
          <ul>
            <li>Key: "sachin" → HashCode: 115, Index: 3 → Found 30 at index 3.  </li>
            <li>Key: "vaibhav" → HashCode: 118, Index: 6 → Traverse linked list → Found 40.  </li>
          </ul>
  
      <li>Key Points:</li>
          <ul>
              <li>O(1) time complexity for `put()` and `get()` unless rehashing occurs.  </li>
              <li>If collision → Linked List traversal until key is found or `null`.  </li>
              <li>If key exists, value is replaced.  </li>
              <li>`null` key has a hash code of 0.  </li>
          </ul>
  
      <li>Example Code:</li>
           <pre>
            map.put(new Key("vishal"), 20);
            map.put(new Key("sachin"), 30);
            map.put(new Key("vaibhav"), 40);
            System.out.println(map.get(new Key("sachin"))); // Output: 30
          </pre>
  </ul>

    <li><b>Hashing Process:</b></li>
    <ul>
        <li>Each key is hashed using its <b>hashCode()</b> method, and the hash value is used to determine the index (or bucket) in the internal array.</li>
        <li>The position within the array is calculated using the formula:
            <pre>index = hash(key) % array.length</pre></li>
    </ul>

    <li><b>Bucket Structure:</b></li>
    <ul>
        <li>When two or more keys hash to the same bucket index, a linked list or tree is used to store those key-value pairs.</li>
        <li>In Java 17, if the number of elements in a bucket exceeds a certain threshold (TREEIFY_THRESHOLD), the list is converted into a balanced red-black tree for efficient lookups and insertions (O(log n)).</li>
    </ul>

    <li><b>Handling Collisions:</b></li>
    <ul>
        <li><b>Chaining:</b> In case of a hash collision, the LinkedList or TreeNode is used to store multiple entries at the same bucket index.</li>
        <li>In Java 17, a bucket will use a tree structure for collision resolution when the bucket exceeds a size of 8 entries (by default). Otherwise, it remains as a linked list.</li>
    </ul>

    <li><b>Rehashing:</b></li>
    <ul>
        <li>If the number of elements in the HashMap exceeds a certain load factor (e.g., 0.75), the capacity of the internal array is doubled (rehashing) to maintain efficient performance.</li>
    </ul>

    <li><b>Performance:</b></li>
    <ul>
        <li>Average Case: Lookup, insert, and delete operations are expected to be <b>O(1)</b> in the average case, thanks to direct indexing of the array and the efficient collision handling mechanism (linked list or balanced tree).</li>
        <li>Worst Case: In case of excessive collisions, where many keys hash to the same index, the worst-case performance could degrade to O(n) (with a linked list). However, in Java 17, collisions are handled more efficiently with the introduction of red-black trees, limiting the worst-case complexity to <b>O(log n)</b>.</li>
    </ul>

    <li><b>Summary of Key Points:</b></li>
    <ul>
        <li>In Java 17, HashMap uses an array of buckets, with each bucket storing either a linked list or a red-black tree to resolve hash collisions efficiently.</li>
        <li>The hashing process determines the bucket where a key-value pair will be placed, and collision resolution uses either a linked list or a balanced tree depending on the number of elements in a bucket.</li>
        <li>Rehashing is performed when the load factor threshold is exceeded to maintain the performance of the HashMap.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HMColl">
  <h5>How does <b>HashMap</b> handle collisions?</h5>

<ul>
    <li><b>Collision in HashMap:</b></li>
    <ul>
        <li>A collision occurs when two keys produce the same hash code, and they map to the same bucket in the internal array of the <b>HashMap</b>.</li>
        <li>By default, <b>HashMap</b> uses the <b>hashCode()</b> method of the key to compute its hash code, and this value is used to determine the bucket where the key-value pair will be stored.</li>
    </ul>

    <li><b>Collision Handling Mechanism:</b></li>
    <ul>
        <li><b>Linked List Method:</b> When a collision occurs (i.e., two keys map to the same bucket), <b>HashMap</b> stores multiple key-value pairs in a linked list within that bucket.</li>
        <li><b>Each element in the linked list</b> contains a key-value pair and a reference to the next element (if there are multiple entries in the same bucket).</li>
    </ul>

    <li><b>Tree-based Bucket (Since Java 8):</b></li>
    <ul>
        <li>Starting from Java 8, if the number of entries in a bucket exceeds a certain threshold (8 by default), <b>HashMap</b> replaces the linked list with a balanced binary search tree (BST) for better performance.</li>
        <li>The tree structure allows for faster searching (logarithmic time complexity) compared to a linked list, which has linear time complexity.</li>
    </ul>

    <li><b>Key Considerations:</b></li>
    <ul>
        <li>Collision resolution is key to maintaining the performance of the <b>HashMap</b>. The fewer the collisions, the faster the operations (add, remove, get) will be.</li>
        <li>If the <b>hashCode()</b> method of the key class is poorly designed (e.g., returning the same hash code for different keys), the performance can degrade significantly, leading to long chains or even trees in a single bucket.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>HashMap</b> handles collisions by using a linked list in each bucket, and from Java 8 onwards, it can use a balanced binary search tree for buckets with a high number of entries to maintain efficient performance.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HMLF">
  <h5>What is the <b>load factor in HashMap</b>, and how does it impact performance?</h5>

<ul>
    <li><b>Load Factor Definition:</b></li>
    <ul>
        <li>The <b>load factor</b> in a <b>HashMap</b> is a measure that determines when to increase the capacity of the map.</li>
        <li>It is the threshold at which the map will resize its internal array (or resize the number of buckets) to maintain efficient performance.</li>
        <li>The default load factor in <b>HashMap</b> is 0.75, meaning when the number of entries exceeds 75% of the current capacity, the map will resize.</li>
    </ul>

    <li><b>Impact of Load Factor on Performance:</b></li>
    <ul>
        <li><b>Resize Operations:</b> When the load factor is exceeded, <b>HashMap</b> performs a resize, which involves rehashing the keys and placing them into new buckets. This is a relatively expensive operation.</li>
        <li><b>Higher Load Factor:</b> If the load factor is set to a higher value (e.g., 0.9), the <b>HashMap</b> will resize less frequently, which may improve memory usage efficiency. However, it can cause more collisions, leading to longer lookup times for entries.</li>
        <li><b>Lower Load Factor:</b> If the load factor is set to a lower value (e.g., 0.5), the map will resize more frequently, resulting in better performance for lookup operations. However, it uses more memory because it creates more buckets upfront.</li>
    </ul>

    <li><b>Default Load Factor:</b></li>
    <ul>
        <li>The default load factor of 0.75 provides a good trade-off between memory usage and performance, balancing the number of resize operations and lookup performance.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li>The <b>load factor</b> in a <b>HashMap</b> directly affects its resizing behavior, which in turn impacts memory usage and performance (lookup and insertion times).</li>
    </ul>
</ul>

</div>
<hr>

<div id="CHM">
  <h5>Why should you use <b>ConcurrentHashMap</b> instead of <b>HashMap</b> in a multi-threaded environment?</h5>
  <ul>
    <li><b>HashMap is not thread-safe:</b> Multiple threads modifying a HashMap can lead to race conditions, data inconsistency, or even infinite loops (due to concurrent modification during resizing).</b>
    <li><b>ConcurrentHashMap is thread-safe:</b> It uses segment locking (before Java 8) and bucket-level locks (Java 8+) to allow safe concurrent access without blocking all operations.</b>
    <li><b>No need for external synchronization:</b> Unlike Collections.synchronizedMap(), ConcurrentHashMap does not require full locking for read operations.</b>
  </ul>
  <b>Example: Issue with HashMap in Multi-Threading</b>
  <ul>
    <pre>
import java.util.HashMap;

public class HashMapMultithreading {
    static HashMap<Integer, String> map = new HashMap&lt;&gt;();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 1; i &lt;= 5; i++) {
                map.put(i, "Value" + i);
                System.out.println("Thread 1 inserted: " + i);
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 1; i &lt;= 5; i++) {
                System.out.println("Thread 2 read: " + map.get(i));
            }
        });

        t1.start();
        t2.start();
    }
}

    </pre>
    <b>Possible Issues with HashMap:</b>
      <li>Race conditions when writing to the map.</li>
      <li>NullPointerException or incorrect values when reading while another thread is writing.</li>
      <li>Infinite loops due to concurrent modification during resizing.</li>
  </ul>
  <b>Solution: Using ConcurrentHashMap</b>
  <ul>
    <pre>
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {
    static ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap&lt;&gt;();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 1; i &lt;= 5; i++) {
                map.put(i, "Value" + i);
                System.out.println("Thread 1 inserted: " + i);
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 1; i &lt;= 5; i++) {
                System.out.println("Thread 2 read: " + map.get(i));
            }
        });

        t1.start();
        t2.start();
    }
}

    </pre>
  </ul>

  <ul>
      <li><b>Thread Safety:</b></li>
      <ul>
          <li><b>ConcurrentHashMap</b> is designed for concurrent access by multiple threads. It allows multiple threads to read and write to the map concurrently without causing inconsistencies or data corruption.</li>
          <li><b>HashMap</b> is not thread-safe. If multiple threads access a <b>HashMap</b> concurrently and at least one thread modifies the map, it can lead to unpredictable behavior and data corruption.</li>
      </ul>

      <li><b>Locking Mechanism:</b></li>
      <ul>
          <li><b>ConcurrentHashMap</b> uses a technique called segmented locking (or bucket-level locking). The map is divided into several segments, and each segment can be locked independently, allowing multiple threads to access different segments concurrently.</li>
          <li><b>HashMap</b> does not have any locking mechanism. If multiple threads modify the map, the entire map might need to be synchronized externally, which can lead to performance bottlenecks.</li>
      </ul>

      <li><b>Performance:</b></li>
      <ul>
          <li><b>ConcurrentHashMap</b> offers higher performance in multi-threaded environments because it allows threads to work concurrently on different segments without blocking each other, minimizing contention.</li>
          <li><b>HashMap</b> may suffer from performance issues in multi-threaded environments, especially when using synchronization mechanisms like synchronized blocks or methods, which can cause threads to block each other.</li>
      </ul>

      <li><b>Atomic Operations:</b></li>
      <ul>
          <li><b>ConcurrentHashMap</b> supports atomic operations, like <b>putIfAbsent</b>, <b>replace</b>, and <b>remove</b>, which allow you to perform certain actions on the map in an atomic and thread-safe manner without needing additional synchronization.</li>
          <li><b>HashMap</b> does not provide such atomic operations, and you would have to manually synchronize operations if you want to ensure thread-safety for specific actions.</li>
      </ul>

      <li><b>Use Case:</b></li>
      <ul>
          <li><b>ConcurrentHashMap</b> is ideal for scenarios where you have frequent concurrent reads and writes from multiple threads, such as in a multi-threaded web application or a highly concurrent server environment.</li>
          <li><b>HashMap</b> is suitable in single-threaded scenarios or when external synchronization is used to make it thread-safe, but it's not recommended in multi-threaded environments due to its lack of built-in synchronization mechanisms.</li>
      </ul>

      <li><b>Summary:</b></li>
      <ul>
          <li><b>ConcurrentHashMap</b> provides built-in thread-safety, better performance in multi-threaded environments, and atomic operations, making it the preferred choice for concurrent applications. <b>HashMap</b> is not thread-safe and should not be used in multi-threaded environments without external synchronization.</li>
      </ul>
  </ul>

</div>
<hr>

<div id="HMCHM">
  <h5>What is the difference between <b>HashMap</b> and <b>ConcurrentHashMap</b>?</h5>

<ul>
    <li><b>Thread Safety:</b></li>
    <ul>
        <li><b>HashMap</b> is not thread-safe, meaning it is not designed to handle concurrent access from multiple threads. If multiple threads modify the map simultaneously, it can lead to inconsistent state or exceptions.</li>
        <li><b>ConcurrentHashMap</b> is thread-safe and designed for concurrent access. It allows multiple threads to read and update the map without locking the entire map, improving performance in multi-threaded environments.</li>
    </ul>

    <li><b>Synchronization:</b></li>
    <ul>
        <li><b>HashMap</b> uses no synchronization. If thread safety is required, the programmer must manually synchronize the map or use a wrapper like <b>Collections.synchronizedMap()</b>.</li>
        <li><b>ConcurrentHashMap</b> uses fine-grained locking. It allows multiple threads to work on different segments of the map at the same time, making it more efficient in high-concurrency scenarios.</li>
    </ul>

    <li><b>Performance:</b></li>
    <ul>
        <li><b>HashMap</b> performs better in a single-threaded scenario because there is no overhead of synchronization.</li>
        <li><b>ConcurrentHashMap</b> might perform slower than <b>HashMap</b> in a single-threaded environment due to the additional synchronization mechanisms in place to ensure thread safety.</li>
    </ul>

    <li><b>Null Keys and Values:</b></li>
    <ul>
        <li><b>HashMap</b> allows one null key and multiple null values.</li>
        <li><b>ConcurrentHashMap</b> does not allow null keys or null values to prevent ambiguity in concurrent operations.</li>
    </ul>

    <li><b>Usage Context:</b></li>
    <ul>
        <li><b>HashMap</b> is ideal when thread safety is not a concern, or if thread safety is managed manually.</li>
        <li><b>ConcurrentHashMap</b> is preferred when dealing with high concurrency and multiple threads accessing or modifying the map simultaneously.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>HashMap</b> is non-thread-safe and faster in single-threaded contexts, but not suitable for concurrent access without external synchronization.</li>
        <li><b>ConcurrentHashMap</b> is thread-safe, designed for concurrent access, but may have a slight performance overhead due to the fine-grained locking mechanism.</li>
    </ul>
</ul>
</div>
<hr>

<div id="WHM">
  <h5>How does <b>WeakHashMap</b> work, and when should it be used?</h5>

<ul>
    <li><b>WeakHashMap Overview:</b></li>
    <ul>
        <li><b>WeakHashMap</b> is a map implementation in Java where the keys are stored as weak references. This means that the garbage collector can reclaim the memory used by the keys if there are no b references to them.</li>
        <li>In a <b>WeakHashMap</b>, the value objects are held using regular references (b references), but the keys are weakly referenced. This allows entries to be automatically removed from the map when the key is no longer referenced outside the map.</li>
    </ul>

    <li><b>How WeakHashMap Works:</b></li>
    <ul>
        <li>When an entry's key is no longer referenced anywhere else in the program (except for the map), the garbage collector can collect the key and the associated value.</li>
        <li>This is unlike a regular <b>HashMap</b>, where the entry remains in the map until it is explicitly removed, regardless of whether the key is being used elsewhere.</li>
    </ul>

    <li><b>When to Use WeakHashMap:</b></li>
    <ul>
        <li><b>Cache-like behavior:</b> <b>WeakHashMap</b> is commonly used for caching scenarios where you want to store temporary data but don't want the map to prevent objects from being garbage collected when they are no longer in use.</li>
        <li><b>Listener patterns:</b> In scenarios where objects act as listeners or handlers, and you want the map to automatically clean up when the listener object is no longer in use.</li>
        <li><b>Memory-sensitive applications:</b> If your application must manage memory carefully and automatically reclaim memory used by unused keys without manual intervention.</li>
    </ul>

    <li><b>Example Use Case:</b></li>
    <ul>
        <li>Consider a scenario where you're storing references to user session data. If a user session is no longer in use (i.e., no b references remain to the session key), the session data should be automatically cleaned up. A <b>WeakHashMap</b> is ideal for such use cases because it allows session data to be garbage collected when the session is no longer referenced.</li>
    </ul>

    <li><b>Key Considerations:</b></li>
    <ul>
        <li><b>WeakHashMap</b> should be used carefully, as objects in the map may disappear unexpectedly if their keys are garbage collected. This may lead to unexpected behaviors in the application.</li>
        <li>It is important to note that the map doesn't guarantee when or if a key will be garbage collected, so developers need to account for possible removal of entries without explicit removal requests.</li>
    </ul>
</ul>

</div>
<hr>

<div id="TMap">
  <h5>Explain about TreeMap</h5>
  <ul>
      <li>Implements Red-Black Tree (self-balancing BST).</li>
      <li>Stores keys in sorted order (natural/comparator).  Keys are stored in ascending order by default.</li>
      <li>Provides log(n) time complexity for put(), get(), and remove().</li>
      <li>NavigableMap Methods: firstKey(), lastKey(), higherKey(), lowerKey().</li>
      <li>Not Thread-Safe: Needs external synchronization for multi-threading.</li>
      <li>No null Keys Allowed: Throws NullPointerException.</li>
      <li><b>Example 1: Basic TreeMap Usage</b></li>
      <pre>
TreeMap<Integer, String> treeMap = new TreeMap&lt;>();
treeMap.put(3, "Python");
treeMap.put(1, "Java");
treeMap.put(2, "C++");
treeMap.put(5, "JavaScript");
treeMap.put(4, "Ruby");
System.out.println("TreeMap: " + treeMap);

<b>Output:</b>
TreeMap: {1=Java, 2=C++, 3=Python, 4=Ruby, 5=JavaScript}
First Key: 1
Last Key: 5
Higher Key than 3: 4
Lower Key than 3: 2
HeadMap (<3): {1=Java, 2=C++}
TailMap (>=3): {3=Python, 4=Ruby, 5=JavaScript}
SubMap (2 to 4): {2=C++, 3=Python, 4=Ruby}
      </pre>
      <li><b>Example 2: Custom Sorting (Descending Order)</b></li>
      <pre>
TreeMap<Integer, String> treeMap = new TreeMap<>(Comparator.reverseOrder());
treeMap.put(10, "Java");
treeMap.put(30, "Python");
treeMap.put(20, "C++");
System.out.println("TreeMap (Descending Order): " + treeMap);

<b>Output:</b>
TreeMap (Descending Order): {30=Python, 20=C++, 10=Java}
      </pre>

  </ul>
</div>
<hr>

<div id="HMNull">
  <h5>Why does <b>HashMap</b> allow one null key but multiple null values?</h5>

<ul>
    <li><b>Null Key:</b></li>
    <ul>
        <li>In <b>HashMap</b>, only one null key is allowed because the key's hash code is used to determine the bucket where the entry is stored. However, the hash code of null is undefined, meaning that there is no specific bucket for multiple null keys.</li>
        <li>If <b>HashMap</b> allowed more than one null key, it would be impossible to differentiate between them based on the hash code alone, leading to ambiguity in the map's structure.</li>
    </ul>

    <li><b>Null Values:</b></li>
    <ul>
        <li><b>HashMap</b> allows multiple null values because the values are stored independently from the keys, and the map does not rely on a value's hash code for placement in the map.</li>
        <li>The map only needs to ensure that the keys are unique, but it has no restriction on how many values can be null since they are not involved in the hash-based placement of entries.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>HashMap</b> allows one null key because there can only be one hash code for null, while it allows multiple null values because the values are not involved in the key's hash-based placement.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HMSize">
  <h5>Explain the <b>resize()</b> operation in HashMap</h5>

<ul>
    <li><b>resize()</b> is an internal operation in <b>HashMap</b> that occurs when the number of entries exceeds a certain threshold (i.e., the load factor). This operation increases the capacity of the map to ensure that it maintains optimal performance.</li>
    
    <li><b>When does resize() occur?</b></li>
    <ul>
        <li>By default, a <b>HashMap</b> starts with an initial capacity of 16 and a load factor of 0.75. This means when the number of entries reaches 75% of the current capacity, the <b>resize()</b> operation is triggered.</li>
        <li>For example, if the initial capacity is 16, the <b>resize()</b> operation occurs when there are 12 entries in the map (16 * 0.75 = 12).</li>
    </ul>

    <li><b>How does resize() work?</b></li>
    <ul>
        <li>The <b>resize()</b> operation involves creating a new, larger internal array to store the entries. The new size is typically doubled (i.e., the capacity is increased by 2 times).</li>
        <li>After resizing, the existing entries are rehashed and placed into the new array. The rehashing involves recalculating the hash codes of the keys and distributing them into the new buckets.</li>
    </ul>

    <li><b>Effect of resize() on performance</b></li>
    <ul>
        <li>Resize operations can be expensive because they require creating a new array and rehashing all the entries, which takes time proportional to the number of entries in the map (i.e., O(n) time complexity).</li>
        <li>This can cause temporary performance degradation, especially when many entries are added in a short time.</li>
    </ul>

    <li><b>Key Points to Remember:</b></li>
    <ul>
        <li>The <b>resize()</b> operation ensures that the <b>HashMap</b> maintains a good balance between time complexity and space usage by adjusting the capacity.</li>
        <li>It is triggered when the map exceeds the threshold determined by the load factor.</li>
        <li>Although resizing is necessary for efficient operation, it can have a performance impact due to the rehashing process.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HMScenario">
  <h5>You need to implement a <b>caching mechanism</b> for a high-traffic website. Which Map implementation will you use?</h5>

<ul>
    <li><b>Best Map Implementation: <b>LinkedHashMap</b></b></li>
    <ul>
        <li><b>LinkedHashMap</b> is the best choice for implementing a caching mechanism where you need to store key-value pairs while maintaining the insertion order.</li>
        <li>It uses a hash table with a linked list to maintain the order of elements. This allows for efficient access and insertion while keeping the order intact.</li>
    </ul>

    <li><b>Why <b>LinkedHashMap</b> is Ideal for Caching:</b></li>
    <ul>
        <li><b>Access Order:</b> <b>LinkedHashMap</b> provides an option to maintain access order (via constructor parameter), which is crucial for Least Recently Used (LRU) caching. When the cache reaches its size limit, you can easily evict the least recently used entry.</li>
        <li><b>Efficiency:</b> Operations like put, get, and <b>remove</b> are typically performed in constant time (O(1)) under most circumstances, making it efficient for a high-traffic website.</li>
    </ul>

    <li><b>Why Not Other Map Implementations?</b></li>
    <ul>
        <li><b><b>HashMap</b>:</b> While <b>HashMap</b> is fast, it doesn't maintain any order (neither insertion nor access order). For caching where order matters (like LRU caching), <b>LinkedHashMap</b> is better suited.</li>
        <li><b><b>TreeMap</b>:</b> It maintains a natural ordering of the keys or custom order based on a comparator. However, this introduces overhead due to sorting, which is not necessary for a caching mechanism where quick access is more important than sorting.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>LinkedHashMap</b> is the optimal choice for a <b>caching mechanism</b> on a high-traffic website, especially if you need to maintain insertion or access order for eviction purposes, such as in an LRU cache.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HMLRU">
  <h5>You are designing an <b>LRU Cache</b> for an e-commerce platform. Which Map implementation is suitable?</h5>

<ul>
    <li><b>Best Map Implementation: <b>LinkedHashMap</b></b></li>
    <ul>
        <li><b>LinkedHashMap</b> is the best choice for implementing an LRU (Least Recently Used) Cache.</li>
        <li>It maintains the insertion order or access order depending on the constructor used.</li>
        <li>By setting the access order to <b>true</b> when creating the map, <b>LinkedHashMap</b> automatically maintains the order in which the entries were last accessed. This is essential for an LRU Cache.</li>
    </ul>

    <li><b>Why <b>LinkedHashMap</b> is Ideal for LRU Cache:</b></li>
    <ul>
        <li>It allows fast access and insertion of elements (O(1) time complexity for get and put operations).</li>
        <li>Using <b>LinkedHashMap</b> with access order enabled automatically keeps track of the most recently accessed elements, which helps in efficiently evicting the least recently used items.</li>
        <li>When the cache exceeds its size limit, you can easily remove the oldest (least recently used) element by iterating over the linked list maintained by the map.</li>
    </ul>

    <li><b>Why Not Other Map Implementations?</b></li>
    <ul>
        <li><b>HashMap</b>: While it provides fast access, it does not maintain any order, making it unsuitable for LRU cache implementations where the access order is critical.</li>
        <li><b>TreeMap</b>: Although it maintains elements in a sorted order, it adds unnecessary complexity and overhead for the LRU use case since sorting is not needed in LRU cache systems.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>LinkedHashMap</b> with access order enabled is the most suitable map implementation for designing an LRU cache, as it efficiently maintains the order of access and allows for fast eviction of least recently used elements.</li>
    </ul>
</ul>

</div>
<hr>

<div id="HMScenario1">
  <h5>In a <b>trading system</b>, you need to store <b>orders with unique IDs sorted by timestamp</b>. Which Map will you use?</h5>

<ul>
    <li><b>Best Map Implementation: <b>TreeMap</b></b></li>
    <ul>
        <li><b>TreeMap</b> is the ideal choice when you need to store key-value pairs that are sorted according to the natural order of the keys or a custom comparator.</li>
        <li><b>TreeMap</b> is a Red-Black tree-based implementation of the <b>Map</b> interface, which maintains the order of elements by their keys.</li>
    </ul>

    <li><b>Why <b>TreeMap</b> is Ideal for Orders Sorted by Timestamp:</b></li>
    <ul>
        <li>The orders can be sorted by their timestamp (which can be the key in the map), and <b>TreeMap</b> will keep the entries sorted automatically.</li>
        <li>Each order will have a unique ID (the value), and the keys will be the timestamps. With this, you can efficiently retrieve the order by its timestamp or range of timestamps.</li>
        <li><b>TreeMap</b> ensures that the orders are always ordered, which is crucial for a trading system that requires fast access to orders based on their timestamp.</li>
    </ul>

    <li><b>Why Not Other Map Implementations?</b></li>
    <ul>
        <li><b><b>HashMap</b></b>: While it provides fast insertion and retrieval (O(1) average time complexity), it does not maintain any order. Since orders need to be sorted by timestamp, <b>HashMap</b> is not suitable.</li>
        <li><b><b>LinkedHashMap</b></b>: Although it maintains the insertion order, it does not sort the keys by timestamp. It may be suitable for cases where you want to maintain the order of insertion but not sorting by timestamp.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>TreeMap</b> is the optimal choice for storing orders with unique IDs sorted by timestamp, as it automatically maintains the order of the keys.</li>
    </ul>
</ul>

</div>
<hr>

<div id="CustomHM">
  <h5>How would you <b>implement your own custom HashMap</b>?</h5>

<ul>
    <li><b>Overview of Custom HashMap Implementation:</b></li>
    <ul>
        <li>A custom HashMap can be implemented by creating a class with an array of "buckets," where each bucket is a list or linked list to handle collisions.</li>
        <li>Each key-value pair will be stored in a "bucket" that corresponds to the hash value of the key. The hash value determines the index of the bucket.</li>
    </ul>

    <li><b>Steps to Implement Custom HashMap:</b></li>
    <ul>
        <li><b>Step 1: Create a HashMap Class</b></li>
        <ul>
            <li>Define a class for your HashMap with an array (or list) of buckets. Each bucket stores a linked list of entries.</li>
            <li>Each entry will store a key-value pair.</li>
        </ul>

        <li><b>Step 2: Define a Hash Function</b></li>
        <ul>
            <li>Implement a hash function to calculate the index for a given key. You can use the key's hashCode method to generate the hash value.</li>
            <li>The hash value should be modulo the number of buckets to map the key to the appropriate bucket index.</li>
        </ul>

        <li><b>Step 3: Handle Collisions</b></li>
        <ul>
            <li>Use a linked list (or another data structure like a balanced tree) to handle collisions in the same bucket.</li>
            <li>If two keys have the same hash code and therefore map to the same bucket, store them as separate entries in the linked list.</li>
        </ul>

        <li><b>Step 4: Implement Basic Operations</b></li>
        <ul>
            <li>Define methods like <b>put(key, value)</b>, <b>get(key)</b>, <b>remove(key)</b>, and <b>containsKey(key)</b>:</li>
            <ul>
                <li><b>put(key, value)</b>: Compute the hash value, map it to the corresponding bucket, and store the key-value pair. If the key already exists, replace the old value.</li>
                <li><b>get(key)</b>: Compute the hash value, access the appropriate bucket, and search for the key in that bucket. Return the value if found.</li>
                <li><b>remove(key)</b>: Compute the hash value, locate the bucket, and remove the key-value pair from the linked list if the key exists.</li>
                <li><b>containsKey(key)</b>: Compute the hash value and check if the key exists in the corresponding bucket.</li>
            </ul>
        </ul>

        <li><b>Step 5: Resize the HashMap (Optional)</b></li>
        <ul>
            <li>If the number of elements in the HashMap exceeds a certain threshold (e.g., 75% of the total capacity), resize the HashMap by increasing the number of buckets and rehashing the existing entries to new buckets.</li>
        </ul>

        <li><b>Step 6: Testing and Debugging</b></li>
        <ul>
            <li>Test the HashMap implementation thoroughly to ensure it handles collisions, resizes, and provides correct behavior for put, get, remove, and containsKey methods.</li>
        </ul>
    </ul>

    <li><b>Example Code of Custom HashMap:</b></li>
    <ul>
        <li>
            <pre>
              import java.util.Objects;

              // Custom HashMap implementation
              class CustomHashMap&lt;K, V&gt; {
                  private static final int INITIAL_CAPACITY = 16; // Default capacity
                  private static final float LOAD_FACTOR = 0.75f; // Load factor for resizing
                  private int size = 0;
                  private Node&lt;K, V&gt;[] table;
              
                  // Node class (Linked List for Collision Handling)
                  static class Node&lt;K, V&gt; {
                      final K key;
                      V value;
                      Node&lt;K, V&gt; next; // Pointer for chaining
              
                      Node(K key, V value) {
                          this.key = key;
                          this.value = value;
                          this.next = null;
                      }
                  }
              
                  // Constructor
                  public CustomHashMap() {
                      table = new Node[INITIAL_CAPACITY];
                  }
              
                  // Hash function
                  private int hash(K key) {
                      return Objects.hashCode(key) & (table.length - 1);
                  }
              
                  // Put method (Inserts Key-Value Pair)
                  public void put(K key, V value) {
                      int index = hash(key);
                      Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value);
              
                      // If no collision, insert directly
                      if (table[index] == null) {
                          table[index] = newNode;
                      } else {
                          // Collision handling using Linked List
                          Node&lt;K, V&gt; current = table[index];
                          Node&lt;K, V&gt; prev = null;
              
                          while (current != null) {
                              if (Objects.equals(current.key, key)) {
                                  current.value = value; // Update value if key exists
                                  return;
                              }
                              prev = current;
                              current = current.next;
                          }
                          prev.next = newNode; // Insert at the end of linked list
                      }
                      size++;
              
                      // Resize if load factor exceeds
                      if (size &gt; LOAD_FACTOR * table.length) {
                          resize();
                      }
                  }
              
                  // Get method (Retrieves Value by Key)
                  public V get(K key) {
                      int index = hash(key);
                      Node&lt;K, V&gt; current = table[index];
              
                      while (current != null) {
                          if (Objects.equals(current.key, key)) {
                              return current.value;
                          }
                          current = current.next;
                      }
                      return null; // Key not found
                  }
              
                  // Remove method
                  public void remove(K key) {
                      int index = hash(key);
                      Node&lt;K, V&gt; current = table[index];
                      Node&lt;K, V&gt; prev = null;
              
                      while (current != null) {
                          if (Objects.equals(current.key, key)) {
                              if (prev == null) {
                                  table[index] = current.next; // Remove first node
                              } else {
                                  prev.next = current.next; // Remove in-between node
                              }
                              size--;
                              return;
                          }
                          prev = current;
                          current = current.next;
                      }
                  }
              
                  // Resize method (Doubles table size when threshold exceeds)
                  private void resize() {
                      Node&lt;K, V&gt;[] oldTable = table;
                      table = new Node[oldTable.length * 2];
                      size = 0;
              
                      for (Node&lt;K, V&gt; headNode : oldTable) {
                          while (headNode != null) {
                              put(headNode.key, headNode.value);
                              headNode = headNode.next;
                          }
                      }
                  }
              
                  // Display method
                  public void display() {
                      for (int i = 0; i &lt; table.length; i++) {
                          System.out.print("Index " + i + ": ");
                          Node&lt;K, V&gt; current = table[i];
                          while (current != null) {
                              System.out.print("[" + current.key + "=" + current.value + "] -&gt; ");
                              current = current.next;
                          }
                          System.out.println("null");
                      }
                  }
              
                  // Main method (Testing)
                  public static void main(String[] args) {
                      CustomHashMap&lt;String, Integer&gt; map = new CustomHashMap&lt;&gt;();
                      map.put("Java", 10);
                      map.put("Python", 20);
                      map.put("C++", 30);
                      map.put("Java", 40); // Updates existing key
              
                      System.out.println("Value for 'Java': " + map.get("Java")); // Output: 40
                      System.out.println("Value for 'Python': " + map.get("Python")); // Output: 20
              
                      map.remove("Python");
                      System.out.println("After removing 'Python': " + map.get("Python")); // Output: null
              
                      map.display();
                  }
              }
              
            </pre>
        </li>
    </ul>
</ul>

</div>
<hr>

<div id="QI">
  <h5>Queue Interface:</h5>
  <p>The <b>Queue</b> interface is part of the <b>java.util</b> package and represents a collection designed for holding elements prior to processing. It is used to model data structures like queues where elements are processed in a First-In-First-Out (FIFO) order. The <b>Queue</b> interface extends the <b>Collection</b> interface and provides methods to add, remove, and examine elements in the queue.</p>

  <p><b>Key Features of the Queue Interface:</b></p>
  <ul>
    <li><b>FIFO Order:</b> Elements are processed in the order they are added (first-in, first-out).</li>
    <li><b>Operations:</b> Common operations include <b>offer()</b> to add, <b>poll()</b> to remove, and <b>peek()</b> to view the front element.</li>
    <li><b>Blocking and Non-blocking Methods:</b> Some implementations support blocking methods like <b>take()</b> and <b>put()</b> for thread-safe operations.</li>
  </ul>

  <p><b>Common Implementations of the Queue Interface:</b></p>
  <ul>
    <li><b>LinkedList</b>: A general-purpose implementation of the <b>Queue</b> interface.</li>
    <li><b>PriorityQueue</b>: A queue where elements are ordered based on their priority (not strictly FIFO).</li>
    <li><b>ArrayBlockingQueue</b>: A thread-safe, bounded queue implementation for concurrent programming.</li>
  </ul>
  <b>1. LinkedList as a Queue</b>
  <ul>
      <li>Implements FIFO (First-In-First-Out).</li>
      <li>Allows null elements.</li>
      <li>Not Thread-Safe.</li>
      <pre>
import java.util.*;
public class LinkedListQueueExample {
    public static void main(String[] args) {
        Queue&lt;String> queue = new LinkedList&lt;&gt;();
        queue.offer("Java");
        queue.offer("Python");
        queue.offer("C++");

        System.out.println("Queue: " + queue);
        System.out.println("Peek: " + queue.peek());  // Front element
        System.out.println("Poll: " + queue.poll());  // Remove front element
        System.out.println("Queue after poll: " + queue);
    }
}
<b>Output:</b>
Queue: [Java, Python, C++]
Peek: Java
Poll: Java
Queue after poll: [Python, C++]
      </pre>
  </ul>
  <b>2. PriorityQueue (Min-Heap)</b>
  <ul>
    <li>Stores elements in natural order (or using a custom comparator).</li>
    <li>Does not allow null values.</li>
    <li>Not Thread-Safe.</li>
    <pre>
import java.util.*;

public class PriorityQueueExample {
    public static void main(String[] args) {
        Queue&lt;Integer> pq = new PriorityQueue&lt;>();
        pq.offer(30);
        pq.offer(10);
        pq.offer(50);
        pq.offer(20);

        System.out.println("PriorityQueue: " + pq);
        System.out.println("Poll: " + pq.poll()); // Removes the smallest element
        System.out.println("Queue after poll: " + pq);
    }
}
<b>output:</b>
PriorityQueue: [10, 20, 50, 30]
Poll: 10
Queue after poll: [20, 30, 50]
    </pre>
  </ul>
  <b>3. ArrayDeque (Double-Ended Queue)</b>
  <ul>
    <li>Faster than LinkedList (No node allocation overhead).</li>
    <li>No capacity restriction.</li>
    <li>Does not allow null values.</li>
    <pre>
import java.util.*;

public class ArrayDequeExample {
    public static void main(String[] args) {
        Queue&lt;String> deque = new ArrayDeque&lt;>();
        deque.offer("Java");
        deque.offer("Python");
        deque.offer("C++");

        System.out.println("ArrayDeque: " + deque);
        System.out.println("Poll: " + deque.poll()); // Removes first element
        System.out.println("Queue after poll: " + deque);
    }
}
<b>output:</b>
ArrayDeque: [Java, Python, C++]
Poll: Java
Queue after poll: [Python, C++]
    </pre>
  </ul>
  <b>4. ConcurrentLinkedQueue (Thread-Safe)</b>
  <ul>
    <li>Non-blocking, thread-safe queue.</li>
    <li>Uses CAS (Compare-And-Swap) for atomic operations.</li>
    <pre>
import java.util.concurrent.*;

public class ConcurrentQueueExample {
    public static void main(String[] args) {
        Queue<Integer> queue = new ConcurrentLinkedQueue<>();
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);

        System.out.println("ConcurrentQueue: " + queue);
        System.out.println("Poll: " + queue.poll()); // Removes head element
        System.out.println("Queue after poll: " + queue);
    }
}
<b>Output:</b>
ConcurrentQueue: [1, 2, 3]
Poll: 1
Queue after poll: [2, 3]

    </pre>
  </ul>
  <b>5. LinkedBlockingQueue (Thread-Safe Blocking Queue)</b>
  <ul>
    <li>Thread-safe, supports blocking operations.</li>
    <li>Has an optional capacity limit.</li>
    <pre>
import java.util.concurrent.*;

public class LinkedBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> queue = new LinkedBlockingQueue<>(2);
        queue.put("Java");
        queue.put("Python");
        
        System.out.println("Queue: " + queue);
        System.out.println("Take: " + queue.take()); // Removes and waits if empty
        System.out.println("Queue after take: " + queue);
    }
}
<b>Output:</b>
Queue: [Java, Python]
Take: Java
Queue after take: [Python]

    </pre>
  </ul>
</div>
<hr>

<div id="QS">
  <h5>What is the difference between <b>Queue and Stack</b>?</h5>

<ul>
    <li><b>Queue:</b></li>
    <ul>
        <li>A Queue follows the <b>First-In-First-Out (FIFO)</b> principle, meaning the element added first will be removed first.</li>
        <li>It is like a queue in real life (e.g., a line at a ticket counter), where the first person in line is the first one to be served.</li>
        <li>Common methods: <b>offer()</b>, <b>poll()</b>, <b>peek()</b>.</li>
        <li>Used when tasks are processed in the order they are received, such as in task scheduling, message processing, and print queues.</li>
    </ul>

    <li><b>Stack:</b></li>
    <ul>
        <li>A Stack follows the <b>Last-In-First-Out (LIFO)</b> principle, meaning the element added last will be removed first.</li>
        <li>It is like a stack of plates, where the last plate placed on the stack is the first one to be removed.</li>
        <li>Common methods: <b>push()</b>, <b>pop()</b>, <b>peek()</b>.</li>
        <li>Used in scenarios like undo operations, function calls, and depth-first search algorithms.</li>
    </ul>

    <li><b>Key Differences:</b></li>
    <ul>
        <li><b>Order of Processing:</b> Queue follows FIFO, Stack follows LIFO.</li>
        <li><b>Real-World Analogy:</b> Queue is like a line of people waiting for a service; Stack is like a stack of plates where the last plate placed is the first one to be used.</li>
        <li><b>Methods:</b> Queue provides methods like <b>offer()</b>, <b>poll()</b>, and <b>peek()</b>, while Stack provides <b>push()</b>, <b>pop()</b>, and <b>peek()</b>.</li>
        <li><b>Use Cases:</b> Queue is used in task scheduling, print queues, and asynchronous processing, while Stack is used in undo features, recursion, and depth-first search.</li>
    </ul>
</ul>

</div>
<hr>

<div id="PQ">
  <h5>How does <b>PriorityQueue</b> work internally?</h5>

<ul>
    <li><b>Internal Data Structure:</b></li>
    <ul>
        <li><b>PriorityQueue</b> is backed by a binary heap, specifically a min-heap by default. The heap structure ensures that the element with the highest priority (or the smallest element in the case of a min-heap) is always at the root of the heap.</li>
        <li>The heap is implemented as an array, and the parent-child relationships are maintained by the indices in this array. For an element at index i:
            <ul>
                <li>The left child is at index 2*i + 1.</li>
                <li>The right child is at index 2*i + 2.</li>
                <li>The parent is at index (i - 1) / 2.</li>
            </ul>
        </li>
    </ul>

    <li><b>Priority Queue Operations:</b></li>
    <ul>
        <li><b>add(E e)</b>: Adds an element to the queue. The new element is placed at the end of the heap (array), and then the heap property is restored by "bubbling up" the element to its correct position.</li>
        <li><b>remove()</b>: Removes the root element (the element with the highest priority). The last element in the heap is moved to the root position, and the heap property is restored by "bubbling down" this element until the heap is in a valid state again.</li>
        <li><b>peek()</b>: Returns the root element without removing it, allowing you to view the highest-priority element without altering the queue.</li>
        <li><b>poll()</b>: Removes and returns the root element, similar to <b>remove()</b>, but it returns null if the queue is empty, rather than throwing an exception.</li>
    </ul>

    <li><b>Heap Property:</b></li>
    <ul>
        <li>The heap always maintains a specific property where the priority (value) of the parent node is always either greater than or less than the values of its children. In a min-heap, the root always holds the smallest value, and in a max-heap, the root holds the largest value.</li>
        <li>This property allows the <b>PriorityQueue</b> to efficiently access the highest-priority element in <b>O(1)</b> time and perform insertions and deletions in <b>O(log n)</b> time.</li>
    </ul>

    <li><b>Custom Ordering:</b></li>
    <ul>
        <li><b>PriorityQueue</b> by default uses natural ordering (ascending order) if the elements are comparable, but you can provide a custom comparator to change the priority order.</li>
        <li>If a comparator is provided, the queue will arrange elements based on the comparator’s ordering instead of their natural order.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>PriorityQueue</b> is backed by a binary heap, offering efficient priority-based element insertion and removal.</li>
        <li>Operations like add, remove, and poll take <b>O(log n)</b> time, while peeking the highest priority element takes <b>O(1)</b> time.</li>
        <li>The queue supports both natural ordering and custom comparators to define the priority of elements.</li>
    </ul>
</ul>

</div>
<hr>

<div id="ADQLDQ">
  <h5>How does <b>ArrayDeque</b> differ from <b>LinkedList-based Deque</b>?</h5>

<ul>
    <li><b>Internal Data Structure:</b></li>
    <ul>
        <li><b>ArrayDeque</b> is backed by a dynamic array, whereas <b>LinkedList-based Deque</b> is backed by a doubly linked list.</li>
    </ul>

    <li><b>Performance of Operations:</b></li>
    <ul>
        <li><b>ArrayDeque</b> provides faster access and modification of elements at both ends, with amortized constant time complexity (O(1)) for operations like addFirst(), addLast(), removeFirst(), and removeLast().</li>
        <li><b>LinkedList-based Deque</b> also offers constant time complexity for these operations, but due to the overhead of managing node pointers, it may have slightly more memory usage and overhead for some cases.</li>
    </ul>

    <li><b>Memory Usage:</b></li>
    <ul>
        <li><b>ArrayDeque</b> uses less memory compared to <b>LinkedList-based Deque</b> because it stores elements in a contiguous array with no extra memory needed for links between nodes.</li>
        <li><b>LinkedList-based Deque</b> requires additional memory for the previous and next node pointers along with the actual data, making it more memory-intensive.</li>
    </ul>

    <li><b>Resizing and Capacity:</b></li>
    <ul>
        <li><b>ArrayDeque</b> dynamically resizes the underlying array when the capacity is exceeded. This resizing may incur a costly time complexity during resizing (O(n)), but amortized over time, the time complexity remains O(1) for most operations.</li>
        <li><b>LinkedList-based Deque</b> does not require resizing because it uses a linked structure where each element points to the next, so memory is allocated dynamically as needed without resizing costs.</li>
    </ul>

    <li><b>Use Case Suitability:</b></li>
    <ul>
        <li><b>ArrayDeque</b> is generally preferred when you have frequent push and pop operations at both ends of the deque, and constant memory usage is a priority.</li>
        <li><b>LinkedList-based Deque</b> might be more appropriate when you require a consistent performance with complex node management (like using nodes in a broader linked structure), though it's less space-efficient than <b>ArrayDeque</b>.</li>
    </ul>

    <li><b>Null Elements:</b></li>
    <ul>
        <li><b>ArrayDeque</b> does not allow null elements. Trying to add null will result in a <b>NullPointerException</b>.</li>
        <li><b>LinkedList-based Deque</b> allows null elements, so it's possible to insert null values if needed.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>ArrayDeque</b> is typically faster and more memory-efficient, especially for scenarios with frequent operations at both ends of the deque and without null element handling.</li>
        <li><b>LinkedList-based Deque</b> provides more flexibility, allowing null elements, but at the cost of additional memory usage and slightly more overhead due to the linked structure.</li>
    </ul>
</ul>

</div>
<hr>

<div id="TSQ">
  <h5>How would you implement a <b>Task Scheduler</b> using a Queue?</h5>

<ul>
    <li><b>Queue Choice: <b>PriorityQueue</b> or <b>LinkedList</b></b></li>
    <ul>
        <li>A <b>PriorityQueue</b> can be used if tasks need to be scheduled based on priority (e.g., high-priority tasks are executed first).</li>
        <li>If the tasks are scheduled in the order they are added, a <b>LinkedList</b> (as a <b>Queue</b>) is a simple and efficient choice.</li>
    </ul>

    <li><b>Task Scheduler Implementation Steps:</b></li>
    <ul>
        <li><b>Step 1:</b> Define the task structure. A task can be represented by a class that includes task details, priority (if needed), and execution time.</li>
        <li><b>Step 2:</b> Use a Queue to store the tasks. You can choose a <b>PriorityQueue</b> for priority-based scheduling or a simple <b>LinkedList</b> for FIFO scheduling.</li>
        <li><b>Step 3:</b> Implement a method to add tasks to the queue. Tasks are added based on their priority or time of arrival.</li>
        <li><b>Step 4:</b> Implement a method to process tasks from the queue. The task with the highest priority (or the first in line) will be processed first.</li>
        <li><b>Step 5:</b> Set up a loop to continuously check the queue for tasks and execute them until all tasks are processed.</li>
    </ul>

    <li><b>Example Code using LinkedList as Queue:</b></li>
    <ul>
        <li>
            <pre>
import java.util.LinkedList;
import java.util.Queue;

class Task {
    String name;
    int timeToExecute;

    public Task(String name, int timeToExecute) {
        this.name = name;
        this.timeToExecute = timeToExecute;
    }
}

public class TaskScheduler {
    Queue<Task> taskQueue = new LinkedList<>();

    public void addTask(Task task) {
        taskQueue.add(task);
        System.out.println("Task added: " + task.name);
    }

    public void processTasks() {
        while (!taskQueue.isEmpty()) {
            Task task = taskQueue.poll();
            System.out.println("Processing task: " + task.name + " (Time to Execute: " + task.timeToExecute + "ms)");
            try {
                Thread.sleep(task.timeToExecute); // Simulate task execution time
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.addTask(new Task("Task1", 2000));
        scheduler.addTask(new Task("Task2", 1000));
        scheduler.addTask(new Task("Task3", 1500));

        scheduler.processTasks();
    }
}
            </pre>
        </li>
    </ul>

    <li><b>Explanation:</b></li>
    <ul>
        <li>The task scheduler uses a <b>LinkedList</b> as a queue where tasks are processed in the order they are added.</li>
        <li>The <b>addTask</b> method adds tasks to the queue, and the <b>processTasks</b> method processes them one by one by calling <b>poll</b> to retrieve the next task and simulating its execution.</li>
        <li>If you need priority-based scheduling, you can replace the <b>LinkedList</b> with a <b>PriorityQueue</b>, where tasks with higher priority are processed first.</li>
    </ul>
</ul>

</div>
<hr>

<div id="SyncConcu">
  <h5>What are <b>synchronized collections vs concurrent collections</b>?</h5>

<ul>
    <li><b>Synchronized Collections:</b></li>
    <ul>
        <li>Synchronized collections are part of the <b>java.util.Collections</b> utility class and are thread-safe due to synchronization.</li>
        <li>Each method in a synchronized collection is wrapped with the synchronized keyword, ensuring that only one thread can access the collection at a time.</li>
        <li>Example: <b>Collections.synchronizedList(new ArrayList())</b></li>
        <li>While synchronized collections are thread-safe, they may lead to performance issues due to the overhead of synchronization. Only one thread can access the collection at a time, which can cause contention and reduce concurrency.</li>
        <li>Accessing the collection in multiple threads requires careful synchronization when iterating over it. It is recommended to manually synchronize on the collection while iterating.</li>
    </ul>

    <li><b>Concurrent Collections:</b></li>
    <ul>
        <li>Concurrent collections are part of the <b>java.util.concurrent</b> package and are designed for high-concurrency environments.</li>
        <li>These collections are optimized for concurrent access by multiple threads without the need for explicit synchronization.</li>
        <li>Examples: <b>CopyOnWriteArrayList</b>, <b>ConcurrentHashMap</b>, <b>BlockingQueue</b>, etc.</li>
        <li>Concurrent collections provide better performance compared to synchronized collections because they allow multiple threads to work on different parts of the collection without blocking each other.</li>
        <li>They internally manage locking or provide lock-free access to data to improve thread safety and avoid bottlenecks.</li>
        <li>Unlike synchronized collections, concurrent collections handle thread safety at a finer level, allowing multiple threads to access independent parts of the collection concurrently.</li>
    </ul>

    <li><b>Key Differences:</b></li>
    <ul>
        <li><b>Synchronization:</b> Synchronized collections use synchronized methods, whereas concurrent collections use advanced techniques like fine-grained locking or lock-free data structures.</li>
        <li><b>Performance:</b> Synchronized collections can suffer from performance degradation due to blocking, whereas concurrent collections are designed for better performance in highly concurrent environments.</li>
        <li><b>Use Cases:</b> Synchronized collections are better for simpler, single-threaded scenarios, while concurrent collections are optimized for high-concurrency, multi-threaded environments.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li>Synchronized collections are a basic way to achieve thread-safety by wrapping collections in synchronized methods, while concurrent collections are more advanced and provide better performance in multi-threaded environments by allowing finer-grained concurrency control.</li>
    </ul>
</ul>

</div>
<hr>

<div id="COWA">
  <h5>How does <b>CopyOnWriteArrayList</b> differ from a synchronized list?</h5>

<ul>
    <li><b>Internal Mechanism:</b></li>
    <ul>
        <li><b>CopyOnWriteArrayList</b> creates a copy of the array whenever it is modified (for example, when an element is added, removed, or replaced). This ensures that iterators can operate on a consistent, unchanging snapshot of the list, even when the list is being modified.</li>
        <li><b>Synchronized list</b> (e.g., <b>Collections.synchronizedList(new ArrayList<>())</b>) simply synchronizes each method call (such as add, remove, etc.) using a lock. This ensures that only one thread can access the list at a time, but it doesn't provide thread-safe iteration without additional synchronization.</li>
    </ul>

    <li><b>Concurrency and Thread Safety:</b></li>
    <ul>
        <li><b>CopyOnWriteArrayList</b> is optimized for scenarios where reads are frequent and writes (modifications) are infrequent. It allows multiple threads to read the list without locking, which is highly beneficial in situations with many concurrent readers.</li>
        <li><b>Synchronized list</b> ensures thread safety by synchronizing each method call. However, it might introduce contention, especially when multiple threads are attempting to modify the list concurrently.</li>
    </ul>

    <li><b>Performance:</b></li>
    <ul>
        <li><b>CopyOnWriteArrayList</b> provides better performance for situations where reads dominate because it doesn't require locking for reading. However, it comes with a performance penalty for writes, as it creates a new copy of the array on each modification.</li>
        <li><b>Synchronized list</b> can have worse performance than <b>CopyOnWriteArrayList</b> in read-heavy scenarios because it locks the list for each operation, which can introduce contention when there are multiple threads trying to read or modify the list simultaneously.</li>
    </ul>

    <li><b>Iteration:</b></li>
    <ul>
        <li><b>CopyOnWriteArrayList</b> allows safe iteration even when the list is being modified concurrently, since it operates on a snapshot copy of the list.</li>
        <li><b>Synchronized list</b> requires external synchronization during iteration to prevent concurrent modification exceptions, as the list is modified directly.</li>
    </ul>

    <li><b>Use Case:</b></li>
    <ul>
        <li><b>CopyOnWriteArrayList</b> is ideal for scenarios where reads significantly outnumber writes, and thread safety for iteration is important.</li>
        <li><b>Synchronized list</b> is better when writes are frequent and thread safety is required for both reading and writing, but you need to manually synchronize iteration to avoid concurrent modification exceptions.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>CopyOnWriteArrayList</b> offers better performance for read-heavy, low-write scenarios with safe iteration, while a <b>synchronized list</b> provides thread safety but may suffer from performance degradation and requires additional synchronization during iteration.</li>
    </ul>
</ul>

</div>
<hr>

<div id="CHMHT">
  <h5>How does <b>ConcurrentHashMap</b> handle concurrency differently than <b>HashTable</b>?</h5>

<ul>
    <li><b>Internal Locking Mechanism:</b></li>
    <ul>
        <li><b>HashTable</b> uses a single lock for the entire map, which means if one thread is accessing the map, other threads are blocked from accessing it, resulting in reduced concurrency.</li>
        <li><b>ConcurrentHashMap</b> uses a finer-grained locking approach by splitting the map into segments (or buckets) and locking only a specific segment when a thread accesses it. This allows multiple threads to concurrently access different segments, improving overall concurrency.</li>
    </ul>

    <li><b>Thread Safety and Performance:</b></li>
    <ul>
        <li><b>HashTable</b> is fully synchronized at the method level, meaning every operation (put, get, remove) locks the entire map, which can cause significant performance degradation in multi-threaded scenarios with high contention.</li>
        <li><b>ConcurrentHashMap</b> allows for higher performance in concurrent environments because it provides thread safety at a more granular level, allowing multiple threads to read and write concurrently without locking the whole map. This results in less contention and better scalability.</li>
    </ul>

    <li><b>Null Keys and Values:</b></li>
    <ul>
        <li><b>HashTable</b> does not allow null keys or null values. If you attempt to insert a null key or value, it throws a <b>NullPointerException</b>.</li>
        <li><b>ConcurrentHashMap</b> does not allow null values, but it allows null keys. This is intentional to prevent ambiguity, as a null value can indicate that the key is not present, but null keys may have a specific use case in certain scenarios.</li>
    </ul>

    <li><b>Performance During High Contention:</b></li>
    <ul>
        <li><b>HashTable</b> degrades significantly under high contention because of the global lock, where only one thread can modify the map at a time.</li>
        <li><b>ConcurrentHashMap</b> handles high contention better due to its segmented locking, allowing multiple threads to work concurrently with fewer performance hits even in heavily contended scenarios.</li>
    </ul>

    <li><b>Method Synchronization:</b></li>
    <ul>
        <li><b>HashTable</b> synchronizes every method in the class, which means every operation is thread-safe but can be slow.</li>
        <li><b>ConcurrentHashMap</b> only synchronizes the operations that need to be thread-safe, allowing other operations like <b>get</b> and <b>containsKey</b> to run without locking and thus perform better in multi-threaded environments.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>HashTable</b> uses a global lock, is fully synchronized, and has performance limitations under high concurrency.</li>
        <li><b>ConcurrentHashMap</b> provides finer-grained locking, allows for better concurrency, and is designed to work more efficiently in highly concurrent environments with less performance degradation.</li>
    </ul>
</ul>

</div>
<hr>

<div id="CSLM">
  <h5>Why is <b>ConcurrentSkipListMap</b> useful in multi-threaded applications?</h5>

<ul>
    <li><b>Thread Safety:</b></li>
    <ul>
        <li><b>ConcurrentSkipListMap</b> is designed for use in multi-threaded environments and provides thread-safe operations without the need for explicit synchronization.</li>
        <li>It allows multiple threads to safely access and modify the map concurrently, making it ideal for high-concurrency scenarios.</li>
    </ul>

    <li><b>Non-blocking Reads and Writes:</b></li>
    <ul>
        <li>The <b>ConcurrentSkipListMap</b> uses a lock-free mechanism that allows threads to perform non-blocking reads, which helps to reduce contention and increase overall performance in highly concurrent systems.</li>
        <li>Read operations are highly optimized, ensuring minimal latency when accessing data.</li>
    </ul>

    <li><b>Ordered Data:</b></li>
    <ul>
        <li>Unlike other thread-safe maps (like <b>Hashtable</b>), <b>ConcurrentSkipListMap</b> maintains a natural ordering of its keys or can use a custom comparator.</li>
        <li>This ordering is maintained even in a multi-threaded environment, making it useful for applications that need to perform range-based queries or iterate over sorted keys in a concurrent manner.</li>
    </ul>

    <li><b>Scalability:</b></li>
    <ul>
        <li><b>ConcurrentSkipListMap</b> provides better scalability than other thread-safe maps, as it handles concurrency more efficiently by using a skip-list data structure, which enables faster search and update times in large data sets.</li>
    </ul>

    <li><b>Useful in Real-time Systems:</b></li>
    <ul>
        <li>Because it allows concurrent read and write operations with minimal locking, <b>ConcurrentSkipListMap</b> is useful in real-time applications where performance is critical, such as in distributed systems or multi-threaded servers.</li>
    </ul>

    <li><b>Comparison with Other Maps:</b></li>
    <ul>
        <li><b>HashMap</b> and <b>Hashtable</b> are not thread-safe, requiring external synchronization for thread safety.</li>
        <li><b>ConcurrentSkipListMap</b> offers better performance for concurrent access compared to <b>Hashtable</b> or <b>Collections.synchronizedMap()</b>, which require full synchronization of operations.</li>
    </ul>

    <li><b>Summary:</b></li>
    <ul>
        <li><b>ConcurrentSkipListMap</b> is an ideal choice for multi-threaded applications where thread safety, ordered data, and high scalability are needed.</li>
    </ul>
</ul>

</div>
<hr>

<div id="TSScenraio">
  <h5>In a <b>multi-threaded data processing system</b>, how would you handle concurrent updates to a shared collection?</h5>

<ul>
    <li><b>Use Thread-Safe Collections</b></li>
    <ul>
        <li>For thread-safe operations on shared collections, you can use <b>Concurrent Collections</b> such as <b>ConcurrentHashMap</b> or <b>CopyOnWriteArrayList</b> in Java.</li>
        <li>These collections are specifically designed to handle concurrent access and updates, ensuring that multiple threads can interact with the collection safely.</li>
    </ul>

    <li><b>Synchronization</b></li>
    <ul>
        <li>If you need to use a non-thread-safe collection like <b>ArrayList</b> or <b>HashMap</b>, you can synchronize the collection explicitly using <b>synchronized</b> blocks or methods.</li>
        <li>For example, <b>synchronized(collection)</b> will lock the collection during updates to ensure that only one thread can modify it at a time.</li>
    </ul>

    <li><b>Using Collections.synchronizedCollection</b></li>
    <ul>
        <li>If you are working with a legacy collection or need thread safety for a general collection, you can wrap it with <b>Collections.synchronizedList</b> or <b>Collections.synchronizedMap</b>.</li>
        <li>This ensures that all operations on the collection are synchronized, making it thread-safe.</li>
    </ul>

    <li><b>Read-Write Locks</b></li>
    <ul>
        <li>In scenarios where reads are more frequent than writes, you can use <b>ReadWriteLock</b> (e.g., <b>ReentrantReadWriteLock</b>) to allow multiple threads to read the collection concurrently but ensure exclusive access for writes.</li>
        <li>This approach improves performance when read operations dominate, as it reduces the contention between threads.</li>
    </ul>

    <li><b>Atomic Operations</b></li>
    <ul>
        <li>For specific atomic operations, you can use the <b>Atomic*</b> classes like <b>AtomicInteger</b>, <b>AtomicLong</b>, or <b>AtomicReference</b> for updating individual elements of the collection in an atomic manner without the need for manual synchronization.</li>
    </ul>

    <li><b>Immutable Collections</b></li>
    <ul>
        <li>If updates are not required after creation, using immutable collections (e.g., using <b>Collections.unmodifiableList</b>) can prevent any concurrent modification issues.</li>
    </ul>

    <li><b>Summary</b></li>
    <ul>
        <li>To handle concurrent updates to a shared collection, prefer using thread-safe collections or synchronize access using locks or explicit synchronization. If the collection needs frequent updates, consider using <b>ConcurrentHashMap</b> or <b>CopyOnWriteArrayList</b> for better performance.</li>
    </ul>
</ul>

</div>
<hr>

<div id="comp">
    <h5>Comparable vs Comparator in Java</h5>
    <p>
      In Java, Comparable and Comparator interfaces are used for sorting objects in collections such as ArrayList, TreeSet, and TreeMap. 
      They allow us to define custom sorting logic for objects.
    </p>
   
    <b>Comparable Interface:</b>
    <ul>
      <li>It is part of the <b>java.lang</b> package.</li>
      <li>Defining the natural ordering of objects.</li>
      <li>Ascending order by default</li>
      <li>A class that implements this interface must override the <b>compareTo()</b> method, which compares the current object with another object of the same type.</li>
      The method returns:
      <ul>
          <li>A negative integer if the current object is less than the specified object.</li>
          <li>A positive integer if the current object is greater than the specified object.</li>
          <li>Zero if the current object is equal to the specified object.</li>
      </ul>
      <pre>
import java.util.*;

class Student implements Comparable<Student> {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Implementing Comparable
    @Override
    public int compareTo(Student other) {
        return this.id - other.id; // Ascending order based on 'id'
    }

    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "'}";
    }
}

public class ComparableExample {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList<>();
        students.add(new Student(3, "Alice"));
        students.add(new Student(1, "Bob"));
        students.add(new Student(2, "Charlie"));

        Collections.sort(students); // Uses Comparable's compareTo()

        System.out.println(students);
    }
}

<b>Output</b>
[Student{id=1, name='Bob'}, Student{id=2, name='Charlie'}, Student{id=3, name='Alice'}]

      </pre>
    </ul>

    <b>Comparator Interface:</b>
    <ul>
      <li>It is part of the <b>java.util</b> package.</li>
      <li>Defining the custom sorting order.</li>
      <li>Method to implement: int compare(T obj1, T obj2)</li>
      <pre>
import java.util.*;

class Student {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "'}";
    }
}

// Comparator for sorting by name
class NameComparator implements Comparator&lt;Student&gt; {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name); // Ascending order of names
    }
}

// Comparator for sorting by id in descending order
class IdDescendingComparator implements Comparator&lt;Student&gt; {
    @Override
    public int compare(Student s1, Student s2) {
        return s2.id - s1.id; // Descending order of IDs
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;();
        students.add(new Student(3, "Alice"));
        students.add(new Student(1, "Bob"));
        students.add(new Student(2, "Charlie"));

        // Sort by name (using NameComparator)
        Collections.sort(students, new NameComparator());
        System.out.println("Sorted by name: " + students);

        // Sort by id in descending order (using IdDescendingComparator)
        Collections.sort(students, new IdDescendingComparator());
        System.out.println("Sorted by ID (Descending): " + students);
    }
}
<b>Output:</b>
Sorted by name: [Student{id=3, name='Alice'}, Student{id=1, name='Bob'}, Student{id=2, name='Charlie'}]
Sorted by ID (Descending): [Student{id=3, name='Alice'}, Student{id=2, name='Charlie'}, Student{id=1, name='Bob'}]
      </pre>
    </ul>
    
    <b>Comparator with Lambda Expressions:</b>
    <ul>
      <pre>
  import java.util.*;

  public class ComparatorLambdaExample {
      public static void main(String[] args) {
          List<Student> students = Arrays.asList(
              new Student(3, "Alice"),
              new Student(1, "Bob"),
              new Student(2, "Charlie")
          );

          // Sorting by name using lambda
          students.sort((s1, s2) -> s1.name.compareTo(s2.name));
          System.out.println("Sorted by name: " + students);

          // Sorting by id in descending order using lambda
          students.sort((s1, s2) -> s2.id - s1.id);
          System.out.println("Sorted by ID (Descending): " + students);
      }
  }
  <b>Output:</b>
  Sorted by name: [Student{id=3, name='Alice'}, Student{id=1, name='Bob'}, Student{id=2, name='Charlie'}]
  Sorted by ID (Descending): [Student{id=3, name='Alice'}, Student{id=2, name='Charlie'}, Student{id=1, name='Bob'}]
      </pre>
    </ul>
    
    <b>When to Use Comparable vs Comparator?</b>
    <ul>
      <b>Use Comparable when:</b>
      <li>The natural ordering of objects makes sense (e.g., Integer, String, Date).</li>
      <li>There is only one sorting criterion (e.g., sorting students by id).</li>
      <b>Use Comparator when:</b>
      <li>You need multiple sorting criteria (e.g., sorting students by name, age, etc.).</li>
      <li>You want to use lambda expressions for concise sorting.</li>
    </ul>
</div>
  
  