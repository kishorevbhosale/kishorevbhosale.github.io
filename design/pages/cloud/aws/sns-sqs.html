<div class="custom-container">
<h3 class="toc-title">Table of Contents</h3>
<ol class="toc-list">
<li><a href="#app-integration-overview">AWS Application Integration Services Overview</a></li>
<li><a href="#sqs">Amazon Simple Queue Service (SQS)</a>
<ol>
<li><a href="#sqs-basics">SQS Basics</a></li>
<li><a href="#sqs-queue-types">Standard vs. FIFO Queues</a></li>
<li><a href="#sqs-visibility">Visibility Timeout</a></li>
<li><a href="#sqs-polling">SQS Polling (Short vs. Long)</a></li>
<li><a href="#sqs-dlq">Dead-Letter Queue (DLQ)</a></li>
<li><a href="#sqs-delay">Delay Queues</a></li>
<li><a href="#sqs-lambda">Lambda with SQS</a></li>
<li><a href="#sqs-extended-client">SQS Extended Client</a></li>
<li><a href="#sqs-monitoring-security">Monitoring & Security</a></li>
<li><a href="#sqs-apis">Key SQS APIs</a></li>
</ol>
</li>
<li><a href="#sns">Amazon Simple Notification Service (SNS)</a>
<ol>
<li><a href="#sns-basics">SNS Basics</a></li>
<li><a href="#sns-topics">SNS Topics & Endpoints</a></li>
<li><a href="#sns-fanout">SNS Fanout</a></li>
</ol>
</li>
<li><a href="#step-functions">AWS Step Functions</a></li>
<li><a href="#swf">Amazon Simple Workflow Service (SWF)</a></li>
<li><a href="#mq">Amazon MQ</a></li>
<li><a href="#kinesis">Amazon Kinesis (Brief)</a></li>
<li><a href="#app-integration-exam-tips">Important Exam Tips & Tricks</a></li>
</ol>
</div>
<hr>

<h3 id="app-integration-overview">AWS Application Integration Services Overview</h3>
<ul>
<li>Suite of services enabling decoupled communication between application components.</li>
<li>Ideal for microservices, distributed systems, and serverless applications.</li>
<li>Connects apps without custom interoperability code.</li>
<li>Decoupled apps are resilient to individual component failures/overloads.</li>
</ul>
<div class="table-responsive-wrapper">
<table class="styled-table">
<thead>
<tr>
<th>Service</th>
<th>What it does</th>
<th>Example Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQS</td>
<td>Messaging queue; store and forward patterns</td>
<td>Building distributed / decoupled applications</td>
</tr>
<tr>
<td>SNS</td>
<td>Set up, operate, and send notifications from the cloud (Pub/Sub)</td>
<td>Send email notification when CloudWatch alarm is triggered</td>
</tr>
<tr>
<td>Step Functions</td>
<td>Out-of-the-box coordination of AWS service components with visual workflow</td>
<td>Order processing workflow, long-running processes</td>
</tr>
<tr>
<td>SWF</td>
<td>Need to support external processes or specialized execution logic (human-enabled workflows)</td>
<td>Order fulfillment system, procedural requests</td>
</tr>
<tr>
<td>Amazon MQ</td>
<td>Managed message broker service for Apache ActiveMQ and RabbitMQ</td>
<td>Migrate existing message queues to AWS (supports industry-standard APIs/protocols)</td>
</tr>
<tr>
<td>Amazon Kinesis</td>
<td>Collect, process, and analyze streaming data</td>
<td>Collect data from IoT devices for later processing</td>
</tr>
</tbody>
</table>
</div>
<hr>

<h3 id="sqs">Amazon Simple Queue Service (SQS)</h3>
<h4 id="sqs-basics">SQS Basics</h4>
<ul>
<li><strong>Definition:</strong> Distributed queue system for sending, storing, and receiving messages between software components.</li>
<li>Acts as a temporary repository/buffer for messages.</li>
<li>Resolves issues of producer/consumer speed mismatch or intermittent connectivity.</li>
<li>Enables decoupling/loose coupling and elasticity.</li>
<li><strong>Pull-based:</strong> Consumers pull messages from the queue (unlike SNS, which is push-based).</li>
<li><strong>Message Size:</strong> Up to 256KB.</li>
<li><strong>Message Retention:</strong> 1 minute to 14 days (default: 4 days).</li>
<li><strong>Delivery Guarantee:</strong> Messages processed at least once. (<strong>Exam Tip!</strong>)</li>
</ul>

<h4 id="sqs-queue-types">Standard vs. FIFO Queues</h4>
<div class="table-responsive-wrapper">
<table class="styled-table">
<thead>
<tr>
<th>Characteristic</th>
<th>Standard Queue</th>
<th>FIFO Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Throughput</strong></td>
<td>Nearly unlimited TPS.</td>
<td>High throughput: Up to 300 messages/sec (3,000 with batching).</td>
</tr>
<tr>
<td><strong>Ordering</strong></td>
<td>Best-effort ordering (messages generally delivered in same order, but can be out of order).</td>
<td>Strictly preserved (First-In-First-Out).</td>
</tr>
<tr>
<td><strong>Delivery Guarantee</strong></td>
<td>At-Least-Once Delivery (occasionally more than one copy).</td>
<td>Exactly-Once Processing (message delivered once, remains until processed/deleted; no duplicates).</td>
</tr>
<tr>
<td><strong>Deduplication</strong></td>
<td>No native deduplication.</td>
<td>Built-in deduplication (via <code>MessageDeduplicationId</code> or content-based SHA-256 hash). Deduplication interval is 5 minutes.</td>
</tr>
<tr>
<td><strong>Message Groups</strong></td>
<td>Not applicable.</td>
<td>Supports Message Groups (via <code>MessageGroupId</code>) for ordered processing within a group. Messages with same Group ID delivered to one consumer at a time.</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>High throughput, general purpose.</td>
<td>Order-sensitive operations (e.g., financial transactions, inventory updates).</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Queue names must be unique within a region.</li>
<li>Scalability: Achieved by creating more queues.</li>
<li>Durability: Messages stored redundantly across multiple AZs.</li>
</ul>

<h4 id="sqs-visibility">Visibility Timeout</h4>
<ul>
<li>Time a message is invisible in the queue after a consumer picks it up.</li>
<li>If not processed/deleted within timeout, message becomes visible again and another consumer can process it (potential duplicate processing).</li>
<li>Default: 30 seconds.</li>
<li>Maximum: 12 hours.</li>
<li>Increase if processing takes longer than default.</li>
</ul>

<h4 id="sqs-polling">SQS Polling (Short vs. Long)</h4>
<ul>
<li><strong>Short Polling (Default):</strong>
<ul>
<li>Returns immediately, even if queue is empty.</li>
<li>Queries only a subset of servers for messages.</li>
<li>More requests, potentially higher cost.</li>
<li><code>ReceiveMessageWaitTime</code> = 0.</li>
</ul>
</li>
<li><strong>Long Polling:</strong>
<ul>
<li>Waits for a message to arrive or for the poll to time out (up to 20 seconds).</li>
<li>Queries all servers, eliminates false empty responses.</li>
<li>Fewer requests, reduces cost.</li>
<li><code>ReceiveMessageWaitTime</code> > 0 (up to 20 seconds).</li>
<li>Shouldn't be used if immediate response is expected.</li>
</ul>
</li>
</ul>

<h4 id="sqs-dlq">Dead-Letter Queue (DLQ)</h4>
<ul>
<li>Handles message failures.</li>
<li>Isolates messages that cannot be processed correctly.</li>
<li>Not a queue type itself; a standard or FIFO queue designated as a DLQ for another queue.</li>
<li>Messages move to DLQ when <code>ReceiveCount</code> exceeds <code>maxReceiveCount</code>.</li>
<li>DLQs should not be used with standard queues if application retries transmission (can break order).</li>
<li>DLQs will break the order of messages in FIFO queues if messages are moved.</li>
<li>DLQ must be the same type (Standard or FIFO) as the source queue.</li>
</ul>

<h4 id="sqs-delay">Delay Queues</h4>
<ul>
<li>Postpones delivery of new messages to a queue for a specified duration.</li>
<li>Messages remain invisible to consumers during the delay period.</li>
<li>Default delay: 0 seconds; Maximum: 900 seconds (15 minutes).</li>
<li>For standard queues, setting only affects new messages; for FIFO, it affects messages already in queue.</li>
<li>Use for large distributed apps needing processing delays (e.g., allowing DB updates before sending notifications).</li>
</ul>

<h4 id="sqs-lambda">Lambda with SQS</h4>
<ul>
<li>SQS can be configured as an event source for AWS Lambda functions.</li>
<li>Lambda polls the SQS queue and invokes your function synchronously with batches of messages.</li>
<li>If function successfully processes a batch, Lambda deletes messages from the queue.</li>
<li>Supports both standard and FIFO queues.</li>
</ul>

<h4 id="sqs-extended-client">SQS Extended Client</h4>
<ul>
<li>Used with Amazon S3 to manage SQS messages larger than 256KB (up to 2GB).</li>
<li>Stores message payload in S3 and sends a small message (reference to S3 object) to SQS.</li>
<li>Client library handles S3 interaction (store, retrieve, delete object).</li>
</ul>

<h4 id="sqs-monitoring-security">Monitoring & Security</h4>
<ul>
<li><strong>Monitoring:</strong> Integrated with CloudWatch (metrics collected every 5 mins, no charge for standard monitoring). CloudWatch considers queue active if messages or API access within 6 hours.</li>
<li><strong>Auditing:</strong> CloudTrail captures SQS API calls.</li>
<li><strong>Security:</strong>
<ul>
<li>IAM policies control read/write access.</li>
<li>In-flight security via HTTPS.</li>
<li>Server-Side Encryption (SSE) using KMS (encrypts message body, not attributes).</li>
<li>Queue access policies provide finer-grained control.</li>
<li>PCI DSS Level 1 compliant and HIPAA eligible.</li>
</ul>
</li>
</ul>

<h4 id="sqs-apis">Key SQS APIs (for Developer Associate Exam)</h4>
<ul>
<li><code>CreateQueue</code>: Creates a new standard or FIFO queue.</li>
<li><code>DeleteQueue</code>: Deletes a queue (successful even if queue doesn't exist).</li>
<li><code>PurgeQueue</code>: Deletes all messages in a queue.</li>
<li><code>SendMessage</code>: Delivers a message to a queue.</li>
<li><code>ReceiveMessage</code>: Retrieves 1-10 messages from a queue. Use <code>WaitTimeSeconds</code> for long polling.</li>
<li><code>DeleteMessage</code>: Deletes a specific message using its <code>ReceiptHandle</code> (<strong>NOT <code>MessageId</code>!</strong>).</li>
<li><code>ChangeMessageVisibility</code>: Changes the visibility timeout of a message.</li>
<li>Batch operations: <code>SendMessageBatch</code>, <code>DeleteMessageBatch</code>, <code>ChangeMessageVisibilityBatch</code> (to reduce costs/requests).</li>
</ul>
<hr>

<h3 id="sns">Amazon Simple Notification Service (SNS)</h3>
<h4 id="sns-basics">SNS Basics</h4>
<ul>
<li><strong>Definition:</strong> Fully managed messaging service for Application-to-Application (A2A) and Application-to-Person (A2P) communication.</li>
<li>Provides pub/sub functionality for high-throughput, push-based, many-to-many use cases.</li>
<li>Used for sending notifications between distributed systems, microservices, and event-driven serverless applications.</li>
<li>Push-based: Publishes messages to subscribers (unlike SQS, which is pull-based).</li>
<li>Inexpensive, pay-as-you-go.</li>
</ul>

<h4 id="sns-topics">SNS Topics & Endpoints</h4>
<ul>
<li><strong>SNS Topics:</strong> Group multiple recipients (subscribers) to receive identical copies of the same notification. An "access point" for subscriptions.</li>
<li>Messages stored redundantly across multiple AZs.</li>
<li>Provides instantaneous, push-based delivery.</li>
<li>Flexible message delivery over multiple transport protocols.</li>
<li><strong>Supported Endpoint Types (Subscribers):</strong>
<ul>
<li>HTTP/HTTPS</li>
<li>Email/Email-JSON</li>
<li>Amazon Kinesis Data Firehose</li>
<li>Amazon SQS queues (common for Fanout)</li>
<li>AWS Lambda functions (common for Fanout)</li>
<li>Platform application endpoint (mobile push: Apple, Google, Fire OS, Windows, Baidu)</li>
<li>SMS</li>
</ul>
</li>
</ul>

<h4 id="sns-fanout">SNS Fanout</h4>
<ul>
<li>Publisher systems can fanout messages to many subscriber systems for parallel processing.</li>
<li>Common fanout patterns: SNS Topic &rarr; multiple SQS Queues, Lambda functions, HTTP/S endpoints, Kinesis Data Firehose delivery streams.</li>
<li>SQS manages the subscription and necessary permissions when subscribing an SQS queue to an SNS topic.</li>
</ul>
<hr>

<h3 id="step-functions">AWS Step Functions</h3>
<ul>
<li><strong>Definition:</strong> Coordinates components of distributed applications as a series of steps in a visual workflow (state machine).</li>
<li>Quickly build and run state machines for reliable, scalable application execution.</li>
<li><strong>How it works:</strong>
<ul>
<li>Define workflow steps in JSON-based Amazon States Language.</li>
<li>Visual console graphs execution flow and highlights real-time status.</li>
<li>Operates and scales application steps and underlying compute automatically.</li>
</ul>
</li>
<li><strong>Features:</strong>
<ul>
<li><strong>Built-in Error Handling:</strong> Tracks state, retries failed/timed-out tasks, catches specific errors, recovers gracefully.</li>
<li><strong>Automatic Scaling:</strong> Scales operations and compute in response to changing workloads.</li>
<li><strong>Pay-per-use:</strong> Billed per state transition (up to one year duration).</li>
<li><strong>Execution Event History:</strong> Detailed logs for troubleshooting.</li>
<li><strong>High Availability:</strong> Built-in fault tolerance across multiple AZs.</li>
<li><strong>Administrative Security:</strong> Integrated with IAM for API access control.</li>
</ul>
</li>
<li><strong>Recommendation:</strong> AWS recommends Step Functions for new applications over SWF. (<strong>Exam Tip!</strong>)</li>
</ul>
<hr>

<h3 id="swf">Amazon Simple Workflow Service (SWF)</h3>
<ul>
<li><strong>Definition:</strong> Web service for coordinating work across distributed application components.</li>
<li>Used for processing background jobs with parallel or sequential steps.</li>
<li>Acts as a fully managed state tracker and task coordinator.</li>
<li>Use if app steps take >500ms, need state tracking, or require recovery/retry on task failure.</li>
<li>Best suited for human-enabled workflows (e.g., order fulfillment, procedural requests).</li>
<li>Workflow executions can have a completion time of up to 1 year.</li>
<li>Uses a task-oriented API.</li>
<li>Ensures tasks are assigned once and never duplicated.</li>
<li><strong>Components:</strong> Domains, Workflows, Activities, Task Lists, Workers, Decider.</li>
<li>Recommendation: AWS recommends Step Functions for new applications instead of SWF. (<strong>Exam Tip!</strong>)</li>
</ul>
<hr>

<h3 id="mq">Amazon MQ</h3>
<ul>
<li><strong>Definition:</strong> Managed message broker service for Apache ActiveMQ and RabbitMQ.</li>
<li>Supports industry-standard APIs and protocols (JMS, NMS, MQTT, WebSockets).</li>
<li><strong>Purpose:</strong> Designed as a drop-in replacement for on-premises message brokers to ease migration without rewriting code. (<strong>Exam Tip!</strong>)</li>
<li>Cost-efficient, flexible, manages administration and maintenance.</li>
<li>Automatically provisions infrastructure for high availability (active/standby brokers across AZs).</li>
<li><strong>Comparison with SQS:</strong>
<ul>
<li>Use SQS if creating a new application from scratch (cloud-native queue).</li>
<li>Use MQ if migrating existing applications that rely on standard message broker APIs.</li>
</ul>
</li>
<li><strong>Security:</strong> Encryption at rest and in transit (SSL), VPC private endpoints, security groups.</li>
<li><strong>Monitoring:</strong> Integrated with CloudWatch and CloudTrail.</li>
</ul>
<hr>

<h3 id="kinesis">Amazon Kinesis (Brief)</h3>
<ul>
<li>Service for collecting, processing, and analyzing streaming data in real-time.</li>
<li>Example use case: Collecting data from IoT devices for later processing.</li>
</ul>
<hr>

<h3 id="app-integration-exam-tips">Important Exam Tips & Tricks</h3>
<ul>
<li><strong>Decoupling is Key:</strong> Understand that all these services primarily aim to decouple application components, improving resilience, scalability, and maintainability.</li>
<li><strong>SQS vs. SNS (Crucial!):</strong>
<ul>
<li><strong>SQS:</strong> Pull-based, message queue, buffer, consumers pull.</li>
<li><strong>SNS:</strong> Push-based, pub/sub, notifications, publishers push to subscribers.</li>
<li>They often work together in a "Fanout" pattern (SNS &rarr; SQS).</li>
</ul>
</li>
<li><strong>SQS Standard vs. FIFO:</strong>
<ul>
<li><strong>Standard:</strong> High throughput, at-least-once delivery, best-effort ordering.</li>
<li><strong>FIFO:</strong> Exactly-once processing, strict ordering, deduplication, message groups (lower throughput).</li>
<li>Know when to use each based on ordering/deduplication requirements.</li>
</ul>
</li>
<li><strong>SQS Visibility Timeout:</strong> Important for preventing duplicate processing. Know its default and max values.</li>
<li><strong>SQS Polling:</strong> Differentiate between short (immediate, more requests) and long (waits, fewer requests, cost-efficient).</li>
<li><strong>SQS Dead-Letter Queues:</strong> For handling failed messages. Understand their impact on FIFO order.</li>
<li><strong>Step Functions vs. SWF:</strong>
<ul>
<li><strong>Step Functions:</strong> Recommended for new apps, visual workflows, state machines, built-in error handling, pay-per-transition.</li>
<li><strong>SWF:</strong> Older, more complex, for human-enabled workflows, long-running processes (up to 1 year).</li>
</ul>
</li>
<li><strong>Amazon MQ vs. SQS:</strong>
<ul>
<li><strong>MQ:</strong> For lift-and-shift of existing applications using standard messaging protocols (ActiveMQ, RabbitMQ).</li>
<li><strong>SQS:</strong> For new cloud-native applications.</li>
</ul>
</li>
<li><strong>Kinesis:</strong> Focus on real-time streaming data processing.</li>
<li><strong>Message Size:</strong> Remember SQS 256KB limit and the SQS Extended Client for larger messages (up to 2GB via S3).</li>
<li><strong>Security:</strong> All services integrate with IAM for access control, and many support SSE (KMS).</li>
</ul>
<hr>