    <div class="container">

        <div class="content">
            <h1 style="text-align: center;">Introduction to Spring Framework</h1>
               
            <h3 class="section-title">What is Spring?</h3>
                <ul>
                    <li>Spring is a mature, powerful, and highly flexible Java framework designed for building web applications.</li>
                    <li>It simplifies Java development by making programming faster, easier, and more secure for developers.</li>
                    <li>Spring focuses on speed, simplicity, and productivity, making it the most popular Java framework globally.</li>
                    <li>It allows the development of secure, reactive cloud-based microservices and complex data flows for enterprise applications.</li>
                    <li>Spring offers built-in support for modern architectures, including microservices, reactive systems, and cloud platforms.</li>
                    <li>The framework regularly introduces new features and projects based on market trends and developer community needs.</li>
                    <li>Spring is open-source with a large, active community that provides continuous support and guidance to developers.</li>
                    <li>It includes various modules such as Spring Boot, Spring MVC, and Spring Cloud, offering solutions for a wide range of use cases.</li>
                    <li>Spring's integration with popular tools and technologies makes it ideal for building scalable, enterprise-level applications.</li>
                    <li>Its flexibility and modular architecture allow developers to pick only the components they need for their project.</li>
                </ul>
                <img src="../../images/spring1.PNG" alt="lb" style="display: block; margin: auto; width: 50%;">
            <br>
            <h3 class="section-title">How Spring Removes Complexity Compared to Previous Java Frameworks</h3>
                <ul>
                    <li>Spring simplifies Java development by reducing the need for extensive boilerplate code, which was common in older frameworks like Java EE.</li>
                    <li>It achieves this through Dependency Injection (DI), which manages object creation and wiring, minimizing manual configurations.</li>
                    <li>Spring provides Spring Boot, a module that eliminates complex XML configurations and allows rapid application setup with embedded servers.</li>
                    <li>Aspect-Oriented Programming (AOP) in Spring simplifies cross-cutting concerns like logging, security, and transaction management.</li>
                    <li>The Spring framework's backend relies on core concepts such as DI, AOP, and a modular architecture to offer flexibility and maintainability.</li>
                    <li>Spring's Inversion of Control (IoC) container manages the lifecycle of Java objects, reducing developer effort in managing dependencies.</li>
                    <li>Spring seamlessly integrates with other Java libraries and frameworks, enabling faster development and reducing complexity.</li>
                    <li>Transaction management, data access, and security handling are abstracted within Spring, allowing developers to focus more on business logic.</li>
                    <li>By abstracting infrastructure concerns, Spring enables developers to build robust applications without needing to manage low-level configuration details.</li>
                </ul>
            <br>
            <h3 class="section-title">Spring Release Timeline</h3>
                <img src="../../images/spring3.PNG" alt="lb" style="display: block; margin: auto; width: 70%;">
            <br>
            <h3 class="section-title">Spring Core</h3>
            <ul>
                <li><strong>Spring Core is the foundation:</strong> It forms the heart of the entire Spring Framework, providing the essential features and utilities used by other Spring modules.</li>
                <li><strong>Backbone of Spring Framework:</strong> The entire Spring ecosystem is built on top of Spring Core, making it critical for all Spring-based applications.</li>
                <img src="../../images/spring4.PNG" alt="lb" style="display: block; margin: auto; width: 30%;">
                <li><strong>Key Modules within Spring Core:</strong> 
                    <ul>
                        <li><strong>Inversion of Control (IoC):</strong> A design principle that ensures the flow of control in the application is managed by the framework, not the developer.</li>
                        <li><strong>Dependency Injection (DI):</strong> A core mechanism that allows objects to be injected into a class, reducing tight coupling and making code more maintainable.</li>
                        <li><strong>Beans:</strong> Central part of the IoC container, used to define and configure Java objects that are managed by Spring.</li>
                        <li><strong>Context:</strong> Provides configuration and lifecycle management, supporting a wide variety of configuration methods (e.g., annotations, XML).</li>
                        <li><strong>Expression Language (SpEL):</strong> A powerful language that can be used to dynamically manipulate objects at runtime, often for conditional logic in Spring configurations.</li>
                        <li><strong>IoC Container:</strong> The container responsible for managing the lifecycle of beans, wiring dependencies, and ensuring object reuse within the application.</li>
                    </ul>
                </li>
            </ul>
            <br>
            <h3 class="section-title">Inversion of Control (IoC)</h3>
            <ul>
                <li><strong>Definition of IoC:</strong> 
                    Inversion of Control (IoC) is a software design principle where the control of object creation and the flow of the program is delegated to a framework rather than the developer writing explicit code to manage it.
                </li>
        
                <li><strong>Flow of Control is Inverted:</strong> 
                    In traditional programming, the flow of control is dictated by the developer. However, in IoC, the framework controls the execution flow, which simplifies program logic and reduces code complexity.
                </li>
        
                <li><strong>IoC Does Not Directly Create Objects:</strong> 
                    IoC doesn't directly create objects but provides guidelines and mechanisms for how objects should be created and managed by the framework. This results in better structure and flexibility within the application.
                </li>
        
                <li><strong>Dependency Injection (DI) Implements IoC:</strong> 
                    DI is a pattern used to implement IoC. It allows the framework (such as Spring) to inject dependencies into a class, rather than the class creating its dependencies. This decouples the class from the dependencies it needs.
                </li>
        
                <li><strong>Responsibility Shifted to IoC Container:</strong> 
                    Through DI, the responsibility of creating and managing objects is shifted from the application code to the Spring IoC container, which handles object creation, lifecycle, and dependency injection.
                </li>
        
                <li><strong>Reduction in Tight Coupling:</strong> 
                    DI reduces the tight coupling between objects by allowing the framework to inject required dependencies dynamically at runtime. This makes code easier to test, modify, and maintain.
                </li>
        
                <li><strong>Example of IoC in Spring:</strong> 
                    In a Spring application, you define beans and their relationships in a configuration file or using annotations. The Spring IoC container takes care of instantiating the beans and wiring them together based on the configuration.
                </li>
            </ul>
            <br>

            <h3 class="section-title">Advantages of Inversion of Control (IoC) and Dependency Injection (DI)</h3>
            <ul>
                <li><strong>Loose Coupling:</strong> IoC and DI facilitate loose coupling between objects. This means that components interact with each other through well-defined interfaces rather than hardcoded dependencies, enhancing modularity and flexibility.</li>
                <li><strong>Reduced Boilerplate Code:</strong> By leveraging IoC and DI, much of the boilerplate code required for object creation and dependency management is eliminated, making the codebase cleaner and easier to manage.</li>
                <li><strong>Ease of Unit Testing:</strong> IoC and DI simplify unit testing by allowing dependencies to be easily mocked or stubbed. This leads to more reliable and isolated tests, improving overall test coverage and quality.</li>
                <li><strong>Improved Maintainability and Reusability:</strong> The decoupling of components enhances maintainability and promotes reusability. Changes in one component are less likely to impact others, making the system more adaptable to modifications.</li>
                <li><strong>Parallel Development:</strong> Loose coupling enables multiple developers to work on different parts of the application simultaneously without interfering with each other's work, facilitating efficient parallel development.</li>
                <li><strong>Easy Object Replacement:</strong> Replacing or updating objects in the system is straightforward and has minimal side effects, as dependencies are managed by the framework rather than hardcoded, allowing for smoother updates and enhancements.</li>
            </ul>
            <br>

            <h3 class="section-title">Spring Bean</h3>
            <ul>
                <li><strong>What is a Spring Bean?</strong> 
                    A Spring Bean is any object(POJO) that is managed by the Spring Inversion of Control (IoC) container. Beans are the fundamental building blocks of a Spring application, managed and configured by the container.
                </li>
        
                <li><strong>How Are Beans Created?</strong> 
                    Spring Beans are created through a configuration class. You can define beans using XML configuration, Java-based configuration classes, or annotations.
                </li>
        
                <li><strong>Lifecycle of a Bean:</strong> 
                    Spring Beans go through a defined lifecycle, including initialization, use, and destruction. The container manages these stages and ensures that beans are properly created, configured, and cleaned up.
                </li>
        
                <li><strong>Not All Objects Are Beans:</strong> 
                    Only objects that are managed by the Spring IoC container qualify as Spring Beans. Objects not managed by the container are not considered beans.
                </li>
        
                <li><strong>How Does the Spring Container Know Which Objects Are Beans?</strong> 
                    The Spring container identifies beans through the configuration provided in XML files, Java-based configuration classes, or annotations. These configurations inform the container about which objects to manage and how to configure them.
                </li>
        
                <li><strong>How to Configure Beans:</strong> 
                    Beans are configured through various methods, including XML configuration, Java configuration classes, or annotations. This configuration defines how the beans should be created, initialized, and wired together.
                </li>
        
                <li><strong>How to Inject Dependencies:</strong> 
                    Dependency Injection (DI) is used to inject dependencies into beans. This can be achieved through XML configuration, Java-based configuration, or annotations. DI allows the container to provide the required dependencies to beans, promoting loose coupling and flexibility.
                </li>
            </ul>
            <br>

            <h3 class="section-title">Spring Context</h3>
                <ul>
                    <li><strong>What is Spring Context?</strong> 
                        The Spring Context, also known as the Application Context, is a central container that holds and manages Spring Beans. It is responsible for instantiating, configuring, and managing the lifecycle of beans in a Spring application.
                    </li>
                    <li><strong>How to Create Spring Context?</strong> 
                        The Spring Context is created using a configuration class, which can be defined through XML configuration, Java-based configuration, or annotations. This configuration informs the container about which beans should be managed.
                    </li>
                    <li><strong>Default Behavior of Spring:</strong> 
                        By default, Spring doesn’t automatically recognize or manage the objects in your application. It requires explicit configuration to understand which objects (beans) should be included in the context.
                    </li>
                    <li><strong>How to Add Objects to the Spring Context:</strong> 
                        To enable Spring to manage your application’s objects, you need to define them as beans and add them to the context. This is done through configuration files (XML), Java-based configuration, or by using annotations such as <b><em>@Component</em></b> or <b><em>@Bean</em></b>.
                    </li>
                    <li><strong>Spring Context in Action:</strong> 
                        Once objects (beans) are added to the Spring Context, they are automatically managed by the Spring IoC container. The context provides features like dependency injection, event propagation, and bean lifecycle management, making the application more modular and flexible.
                    </li>
                </ul>
            <br>

            <h3 class="section-title">Understanding Spring Expression Language (SpEL)</h3>

            <ul>
                <li><strong>What is Spring Expression Language (SpEL)?</strong> 
                    Spring Expression Language (SpEL) is a powerful language used within the Spring Framework to evaluate expressions at runtime. It allows dynamic querying, manipulation of object graphs, and interaction with Spring beans.
                </li>
        
                <li><strong>Key Features of SpEL:</strong> 
                    SpEL is a highly versatile language that enables:
                    <ul>
                        <li>Reading and writing properties of objects.</li>
                        <li>Invoking methods on objects at runtime.</li>
                        <li>Accessing collections, arrays, and maps.</li>
                        <li>Working with logical, relational, and mathematical expressions.</li>
                        <li>Using Spring-specific features such as bean references, environment properties, and more.</li>
                    </ul>
                </li>
        
                <li><strong>Usage Example:</strong> 
                    SpEL expressions are commonly used in Spring configurations and annotations. For example, <b><em>${name}</em></b> is an expression used to access the value of the "name" property dynamically.
                </li>
        
                <li><strong>Practical Application of SpEL:</strong> 
                    SpEL can be embedded within annotations like <b><em>@Value</em></b> to dynamically inject values into Spring Beans. It is also used in conditional statements, configuration properties, and more, making it a flexible tool for runtime decision-making in Spring applications.
                </li>
            </ul>
            <br>

            <h3 class="section-title">Understanding Spring IoC Container</h3>

            <ul>
                <li><strong>What is the Spring IoC Container?</strong> 
                    The Spring Inversion of Control (IoC) container is responsible for managing the beans in a Spring application. It handles the creation, configuration, and management of Spring beans.
                </li>
                <img src="../../images/spring5.PNG" alt="lb" style="display: block; margin: auto; width: 50%;">
                <li><strong>Responsibilities of the IoC Container:</strong>
                    The IoC container is tasked with:
                    <ul>
                        <li>Creating beans based on the provided configuration.</li>
                        <li>Wiring or injecting dependencies between beans.</li>
                        <li>Managing the lifecycle of beans, from creation to destruction.</li>
                    </ul>
                </li>
                
                <li><strong>Types of Spring IoC Containers:</strong> 
                    Spring provides two types of IoC containers:
                    <ul>
                        <li><strong>BeanFactory:</strong> The simplest IoC container in Spring. It provides basic bean management capabilities like instantiating and configuring beans lazily, on demand.</li>
                        <li><strong>ApplicationContext:</strong> A more advanced IoC container. It builds on the features of BeanFactory and adds additional functionalities such as event propagation, declarative mechanisms, internationalization, and automatic bean creation.</li>
                    </ul>
                </li>
        
                <li><strong>How to Create the IoC Container?</strong> 
                    The IoC container can be created using configuration files such as XML, Java-based configuration classes, or annotations. These configurations inform the container about which beans to manage and how to wire them together.
                </li>
        
                <li><strong>Dependency Injection with IoC Container:</strong> 
                    The Spring IoC container uses Dependency Injection (DI) to inject dependencies into the beans. This allows beans to be loosely coupled, as the container manages the dependencies and wiring automatically.
                </li>
            </ul>
        
        </div>
    </div>


