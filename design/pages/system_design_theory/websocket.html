  <div>
    <h2 style="text-align: center;">Understanding of WebSocket</h2>
    <hr>
    <h5>What is a WebSocket Handler?</h5>
    <p>
      A <b>WebSocket handler</b> is a component or module in a server that manages WebSocket 
      connections, processes client messages, and sends responses in real time. WebSockets provide a 
      <em>full-duplex communication channel</em> over a single TCP connection, enabling real-time interaction 
      between clients and servers.
    </p>
  </div>
  <hr>
  
  <div>
    <h5>How WebSocket Works (Internal Structure)</h5>
    <ul>
      <li>
        <b>Handshake Phase:</b>
        <p>
          - The WebSocket connection starts with an HTTP request from the client to the server, called a handshake.
          The client sends a special header (e.g., "Upgrade: websocket") to upgrade the connection to WebSocket.
        </p>
        <p>
          - The server responds with a "101 Switching Protocols" response if the WebSocket handshake is successful.
        </p>
      </li>
      <li>
        <b>Connection Phase:</b>
        <p>
          - Once the handshake is complete, the connection is established, and both the client and server 
          can send messages to each other in real time without needing to re-establish the connection.
        </p>
      </li>
      <li>
        <b>Message Exchange:</b>
        <p>
          - Data is transmitted in a lightweight binary format (frames) with very low latency.
          The server can push messages to the client anytime, and the client can send updates to the server without 
          polling.
        </p>
      </li>
      <li>
        <b>Closure:</b>
        <p>
          - Either the client or the server can close the connection. The closure is signaled using a special frame. 
          Clean closure ensures proper resource cleanup.
        </p>
      </li>
    </ul>
  </div>
  <hr>

  <div>
    <h5>How WebSocket is Different from HTTP?</h5>
    <ul>
      <li>
        <b>Communication Mode:</b>
        <p>
          - HTTP is <em>request-response based</em>, meaning the client must send a request to get a response from the server.  
          - WebSocket is <em>full-duplex</em>, enabling the client and server to communicate in both directions simultaneously.
        </p>
      </li>
      <li>
        <b>Connection Persistence:</b>
        <p>
          - HTTP connections are <em>stateless</em> and short-lived. Each request creates a new connection.  
          - WebSockets maintain a <em>persistent connection</em> throughout the session.
        </p>
      </li>
      <li>
        <b>Latency:</b>
        <p>
          - HTTP involves a new handshake for every request, adding overhead.  
          - WebSockets, once established, have <em>lower latency</em> as they avoid repeated handshakes.
        </p>
      </li>
      <li>
        <b>Use Cases:</b>
        <p>
          - HTTP is suitable for one-time requests like loading a webpage or retrieving a file.  
          - WebSockets are ideal for <em>real-time applications</em> like chat apps, live notifications, and multiplayer games.
        </p>
      </li>
      <li>
        <b>Data Format:</b>
        <p>
          - HTTP transmits data in text or JSON format (higher overhead).  
          - WebSockets transmit data as lightweight frames, which can be binary or text (lower overhead).
        </p>
      </li>
    </ul>
  </div>
  <hr>

  <div>
    <h5>Key Points to Remember</h5>
    <ul>
      <li>WebSockets enable <b>real-time, low-latency, bi-directional communication</b>.</li>
      <li>They are better suited for use cases like chat applications, live notifications, real-time dashboards, 
          multiplayer gaming, and collaborative tools.</li>
      <li>WebSockets use <b>less bandwidth</b> than traditional HTTP requests (no need for repeated 
          request-response cycles).</li>
      <li>They run on a single TCP connection and are initiated using a WebSocket handshake via HTTP.</li>
      <li>Consider implementing <b>ping-pong messages</b> (heartbeat mechanism) to keep the connection alive.</li>
      <li>Implement proper error handling and reconnection logic for resilience.</li>
    </ul>
  </div>
  <hr>

  <div>
    <h5>How to Implement a WebSocket Handler</h5>
    <ul>
      <li>
        <b>Choose a WebSocket Library:</b>
        <p>
          Use libraries or frameworks like <code>Socket.IO</code> (Node.js), <code>WebSocket API</code> (JavaScript), 
          or server-side libraries like <code>Spring WebSocket</code> (Java), or <code>Flask-SocketIO</code> (Python).
        </p>
      </li>
      <li>
        <b>Set Up the WebSocket Endpoint:</b>
        <p>
          Define an endpoint (e.g., <code>ws://example.com/socket</code>) for clients to connect to. 
        </p>
      </li>
      <li>
        <b>Handle Events:</b>
        <ul>
          <li>
            <b>On Connection:</b> Authenticate the client, log the connection, and store session details.
          </li>
          <li>
            <b>On Message:</b> Process incoming messages, perform required actions, and send responses.
          </li>
          <li>
            <b>On Disconnection:</b> Clean up resources, log the event, and notify other services if needed.
          </li>
        </ul>
      </li>
      <li>
        <b>Implement Security:</b>
        <p>
          - Use SSL/TLS to secure WebSocket connections (e.g., <code>wss://</code> protocol).  
          - Validate incoming messages and sanitize user input to prevent injection attacks.
        </p>
      </li>
      <li>
        <b>Implement Scalability:</b>
        <p>
          - Use load balancers that support WebSocket connections.  
          - Employ message brokers (e.g., RabbitMQ, Kafka) for scaling event handling across multiple servers.
        </p>
      </li>
      <li>
        <b>Test the Handler:</b>
        <p>
          Use tools like <code>Postman</code> or <code>wscat</code> for manual testing, and integrate automated tests.
        </p>
      </li>
    </ul>
  </div>
  <hr>
  