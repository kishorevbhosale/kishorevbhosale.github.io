<div>
  <h2 style="text-align: center">Ecommerce Platform like Amazon or Flipkart</h2>
  <hr />

  <h5>Functional Requirements</h5>
  <ul>
    <li><b>User-facing functionality:</b></li>
    <ul>
      <li>Product search and browse.</li>
      <li>Adding items to cart or wishlist.</li>
      <li>Placing orders.</li>
      <li>User profile and order tracking.</li>
      <li>Notifications for updates (e.g., delivery status).</li>
    </ul>
    <li><b>Backend functionality:</b></li>
    <ul>
      <li>Inventory management.</li>
      <li>Pricing and offers.</li>
      <li>Order processing and serviceability checks.</li>
      <li>Payment integration.</li>
      <li>Shipping and logistics coordination.</li>
    </ul>
  </ul>
  <hr />

  <h5>Non-Functional Requirements:</h5>
  <ul>
    <li>High scalability (handle millions of users and requests).</li>
    <li>Low latency for search, cart, and checkout flows.</li>
    <li>High availability (no downtime).</li>
    <li>Eventual consistency for inventory updates.</li>
    <li>Secure payments and sensitive data handling.</li>
  </ul>
  <p>
    In high-traffic systems, especially during events like major sales,
    balancing non-functional requirements such as availability, consistency, and
    low latency is challenging. Different system components can prioritize these
    requirements differently based on their purpose:
  </p>
  <ul>
    <li>
      <strong>Payment and Inventory Systems:</strong> Emphasize
      <strong>high consistency</strong> to prevent errors, even at the cost of
      availability during peak loads.
    </li>
    <li>
      <strong>Search System:</strong> Focus on
      <strong>high availability</strong> to ensure smooth user interactions,
      accepting slight inconsistencies as acceptable trade-offs.
    </li>
    <li>
      <strong>User-Facing Components:</strong> Prioritize
      <strong>low latency</strong> for an optimal user experience, even if data
      consistency has minor delays.
    </li>
  </ul>
  <p>
    By tailoring non-functional priorities to specific components, the system
    ensures efficient performance while handling high traffic effectively.
  </p>
  <hr />

  <div id="system-flow-points">
    <h3>High level design:</h3>
    <img
      src="../../../images/amazon.png"
      alt="cache"
      style="display: block; margin: auto; width: 100%"
    />
    <ul>
      <li>
        <b>Managing Suppliers with Inbound Services:</b>
        <ul>
          <li>
            Inbound Services interact with supplier systems to fetch inventory
            and item data.
          </li>
          <li>
            When a new supplier or item is added, this information flows through
            Kafka via events generated by Inbound Services.
          </li>
          <li>
            Consumers listening to Kafka process these events to update
            user-facing services like the homepage and search results.
          </li>
        </ul>
      </li>
      <li>
        <b>Item Service:</b>
        <ul>
          <li>Consumes Kafka events to onboard new items.</li>
          <li>Exposes APIs for adding, updating, and fetching items.</li>
          <li>
            Uses MongoDB to store unstructured item data (e.g., shirts vs. TVs
            with different attributes).
          </li>
        </ul>
      </li>
      <li>
        <b>Search Consumer:</b>
        <ul>
          <li>
            Processes newly onboarded items and stores them in ElasticSearch.
          </li>
          <li>
            ElasticSearch supports efficient text-based and fuzzy search for a
            seamless user experience.
          </li>
        </ul>
      </li>
      <li>
        <b>Search Service:</b>
        <ul>
          <li>
            Interacts with ElasticSearch to expose APIs for filtering, sorting,
            and searching products.
          </li>
          <li>
            Communicates with Serviceability and TAT service to ensure search
            results only show deliverable items.
          </li>
          <li>
            Serviceability calculates routes, delivery eligibility, and
            estimated delivery dates.
          </li>
        </ul>
      </li>
      <li>
        <b>Wishlist and Cart Services:</b>
        <ul>
          <li>
            Provide APIs to fetch, add, update, or delete items from wishlists
            or carts.
          </li>
          <li>
            Use separate MySQL databases for scalability, as wishlists and carts
            can grow large during sales.
          </li>
        </ul>
      </li>
      <li>
        <b>Analytics and Recommendations:</b>
        <ul>
          <li>
            Kafka feeds events from searches, wishlists, and carts to Spark
            Streaming Consumers.
          </li>
          <li>
            Generates real-time insights like most popular products or
            categories.
          </li>
          <li>
            Stores data in Hadoop for running algorithms like ALS to create
            personalized recommendations.
          </li>
          <li>
            Recommendations are managed by a Recommendation Service and
            displayed based on user preferences or product categories.
          </li>
        </ul>
      </li>
      <li>
        <b>User Service:</b>
        <ul>
          <li>
            Manages user data with APIs for fetching, updating, adding, or
            deleting user details.
          </li>
          <li>Uses Redis for caching and MySQL for persistent storage.</li>
          <li>
            For example, user pin codes are cached for faster access when
            calculating delivery routes.
          </li>
        </ul>
      </li>
      <li>
        <b>Serviceability and TAT Service:</b>
        <ul>
          <li>
            Works with Logistic and Warehouse Services to compute delivery
            eligibility and ETA.
          </li>
          <li>
            Pre-computes and caches results to deliver instant responses to
            users.
          </li>
        </ul>
      </li>
      <li>
        <b>Placing Orders:</b>
        <ul>
          <li>
            The flow starts with user searches and ends with verified
            deliverable items ready for order placement.
          </li>
          <li>
            All steps in the system ensure seamless product discovery, delivery
            eligibility, and user satisfaction.
          </li>
        </ul>
      </li>
    </ul>

    <div id="order-placement-flow">
      <h5>Order Placement Flow</h5>
      <ul>
        <li>
          <strong>Order Placement:</strong>
          <ul>
            <li>
              When a user wants to place an order, the request goes to the Order
              Taking Service (part of the Order Management System).
            </li>
            <li>
              The Order Management System uses a MySQL database to track various
              tables like customer, item, and order tables.
            </li>
            <li>
              ACID properties of MySQL are crucial to prevent issues like two
              users ordering the last item (e.g., last AirPods) simultaneously.
            </li>
          </ul>
        </li>
        <li>
          <strong>Order Record in Redis:</strong>
          <ul>
            <li>
              As soon as the order is placed, an order record is created in
              Redis with an order ID, date, time, and expiry time (e.g., 10:01
              to 10:05).
            </li>
            <li>The order status is initially marked as "created".</li>
          </ul>
        </li>
        <li>
          <strong>Inventory Update:</strong>
          <ul>
            <li>
              The system calls the Inventory Service to update the stock. For
              example, if 5 Sony TVs were available, the count will be reduced
              to 4.
            </li>
            <li>
              Inventory is updated before proceeding to payment, even though the
              payment hasn't been completed yet, to prevent overselling.
            </li>
            <li>
              If stock is low, only valid buyers proceed to the payment stage.
            </li>
          </ul>
        </li>
        <li>
          <strong>Payment Flow:</strong>
          <ul>
            <li>
              The Order Taking Service then calls the Payment Service, which
              processes the payment through the Payment Gateway.
            </li>
            <li>
              Three possible payment outcomes are handled:
              <ul>
                <li>
                  Success: Update the order status to "placed" and trigger a
                  Kafka event.
                </li>
                <li>
                  Failure: Update order status to "canceled", rollback
                  inventory, and trigger a Kafka event.
                </li>
                <li>
                  No Response: Order expiry triggers the order status to
                  "canceled" and inventory is restored. Expiry handled by Redis.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <strong>Race Condition Prevention:</strong>
          <ul>
            <li>
              If payment success and order expiry occur around the same time,
              race conditions are avoided by deleting Redis records once payment
              is confirmed.
            </li>
            <li>
              If payment is successful but order expired (due to timing),
              options include either refunding the customer or completing the
              order and marking it as "placed".
            </li>
          </ul>
        </li>
        <li>
          <strong>Inventory Update for Search:</strong>
          <ul>
            <li>
              Once an order is confirmed, the inventory count is updated, and
              items going out of stock are removed from search results to
              prevent further orders.
            </li>
          </ul>
        </li>
        <li>
          <strong>MySQL Database Scalability:</strong>
          <ul>
            <li>MySQL becomes a bottleneck as order data grows over time.</li>
            <li>
              To optimize, delivered or canceled orders are moved from MySQL to
              Cassandra for better scalability.
            </li>
            <li>
              Order Processing Service and Historical Order Service manage the
              data migration process.
            </li>
            <li>
              Historical order data in Cassandra helps reduce load on MySQL
              while maintaining efficient queries.
            </li>
          </ul>
        </li>
        <li>
          <strong>Cassandra Use Case:</strong>
          <ul>
            <li>
              Cassandra is used for large datasets with finite queries (e.g.,
              fetching orders by ID, status, created date, etc.), making it
              suitable for orders that are completed or canceled.
            </li>
          </ul>
        </li>
        <li>
          <strong>Orders View:</strong>
          <ul>
            <li>
              Users can view both ongoing and completed orders via the Orders
              View.
            </li>
            <li>
              An intermediate service communicates with the Order Processing
              Service and Historical Order Service to fetch order details.
            </li>
          </ul>
        </li>
        <li>
          <strong>Notifications:</strong>
          <ul>
            <li>
              Every order update (e.g., order placed, in transit, or delivered)
              triggers a notification to either the seller or the customer.
            </li>
            <li>
              Notifications are handled by a dedicated Notification Service.
            </li>
          </ul>
        </li>
        <li>
          <strong>Analytics and Recommendations:</strong>
          <ul>
            <li>
              Kafka collects events from the system, which are processed by
              Spark Streaming for real-time reports.
            </li>
            <li>
              Data is dumped into a Hadoop cluster for further analysis and
              running algorithms to generate personalized product
              recommendations.
            </li>
            <li>
              These recommendations are stored in the Recommendation Service and
              shown to users accordingly.
            </li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
  <hr />

  <div>
    <h3>API Design</h3>

    <div>
      <h5>1. Inbound Services APIs</h5>
      <div>
        <b>Fetch Supplier Inventory</b>
        <p><strong>GET /suppliers/{supplier_id}/inventory</strong></p>
        <p>
          <strong>Description:</strong> Fetch inventory data for a supplier.
        </p>
        <pre>
      {
        "supplier_id": "123",
        "items": [
            { "item_id": "101", "stock": 20 },
            { "item_id": "102", "stock": 10 }
        ]
      }
                    </pre
        >
      </div>
      <div>
        <b>Add New Item</b>
        <p><strong>POST /items</strong></p>
        <p><strong>Description:</strong> Add a new item to the system.</p>
        <pre>
      {
        "item_id": "103",
        "name": "Sony 65” TV",
        "category": "Electronics",
        "attributes": {
            "brand": "Sony",
            "resolution": "4K"
        }
      }
                    </pre
        >
      </div>
    </div>

    <div>
      <h5>2. Item Service APIs</h5>
      <div>
        <b>Get Item Details</b>
        <p><strong>GET /items/{item_id}</strong></p>
        <pre>
      {
        "item_id": "103",
        "name": "Sony 65” TV",
        "category": "Electronics",
        "stock": 5,
        "price": 999.99
      }
                    </pre
        >
      </div>
      <div>
        <b>Update Item</b>
        <p><strong>PUT /items/{item_id}</strong></p>
        <pre>
      {
        "price": 899.99,
        "stock": 4
      }
                    </pre
        >
      </div>
    </div>

    <div>
      <h5>3. Search Service APIs</h5>
      <div>
        <b>Search Items</b>
        <p><strong>GET /search</strong></p>
        <p>
          <strong>Query Parameters:</strong>
          ?query=TV&sort=price&filter=category:Electronics
        </p>
        <pre>
      [
        { "item_id": "101", "name": "Sony 65” TV", "price": 899.99 },
        { "item_id": "102", "name": "Samsung 55” TV", "price": 799.99 }
      ]
                    </pre
        >
      </div>
    </div>

    <div>
      <h5>4. Wishlist and Cart APIs</h5>
      <div>
        <b>Get Wishlist</b>
        <p><strong>GET /users/{user_id}/wishlist</strong></p>
        <pre>
      [
        { "item_id": "101", "name": "Sony 65” TV", "price": 899.99 }
      ]
                    </pre
        >
      </div>
      <div>
        <b>Add to Wishlist</b>
        <p><strong>POST /users/{user_id}/wishlist</strong></p>
        <pre>
      { "item_id": "101" }
                    </pre
        >
      </div>
      <div>
        <b>Get Cart</b>
        <p><strong>GET /users/{user_id}/cart</strong></p>
        <pre>
      [
        { "item_id": "101", "quantity": 1, "price": 899.99 }
      ]
                    </pre
        >
      </div>
      <div>
        <b>Add to Cart</b>
        <p><strong>POST /users/{user_id}/cart</strong></p>
        <pre>
      { "item_id": "101", "quantity": 1 }
                    </pre
        >
      </div>
    </div>

    <div>
      <h5>5. Order APIs</h5>
      <div>
        <b>Place Order</b>
        <p><strong>POST /orders</strong></p>
        <pre>
      {
        "user_id": "u123",
        "items": [{ "item_id": "101", "quantity": 1 }]
      }
                    </pre
        >
      </div>
      <div>
        <b>Get Order Details</b>
        <p><strong>GET /orders/{order_id}</strong></p>
        <pre>
      {
        "order_id": "o123",
        "user_id": "u123",
        "status": "placed",
        "items": [{ "item_id": "101", "quantity": 1 }],
        "total_price": 899.99
      }
                    </pre
        >
      </div>
    </div>

    <div>
      <h5>6. Notification APIs</h5>
      <div>
        <b>Send Notification</b>
        <p><strong>POST /notifications</strong></p>
        <pre>
      {
        "user_id": "u123",
        "type": "order_placed",
        "message": "Your order has been placed successfully!"
      }
                    </pre
        >
      </div>
    </div>

    <div>
      <h5>7. Analytics and Recommendations APIs</h5>
      <div>
        <b>Get Recommendations</b>
        <p><strong>GET /users/{user_id}/recommendations</strong></p>
        <pre>
      [
        { "item_id": "102", "name": "Samsung 55” TV", "price": 799.99 }
      ]
                    </pre
        >
      </div>
    </div>
  </div>
  <hr />

  <div>
    <h3>Database Schema</h3>

    <div>
      <h5>1. MySQL Database (Order Management)</h5>
      <b>Table: users</b>
      <table border="1">
        <thead>
          <tr>
            <th>Column</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>user_id</td>
            <td>VARCHAR(50)</td>
            <td>Primary Key</td>
          </tr>
          <tr>
            <td>name</td>
            <td>VARCHAR(255)</td>
            <td>User name</td>
          </tr>
          <tr>
            <td>email</td>
            <td>VARCHAR(255)</td>
            <td>User email</td>
          </tr>
          <tr>
            <td>password_hash</td>
            <td>VARCHAR(255)</td>
            <td>Encrypted password</td>
          </tr>
          <tr>
            <td>phone</td>
            <td>VARCHAR(15)</td>
            <td>Contact number</td>
          </tr>
        </tbody>
      </table>

      <b>Table: items</b>
      <table border="1">
        <thead>
          <tr>
            <th>Column</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>item_id</td>
            <td>VARCHAR(50)</td>
            <td>Primary Key</td>
          </tr>
          <tr>
            <td>name</td>
            <td>VARCHAR(255)</td>
            <td>Item name</td>
          </tr>
          <tr>
            <td>category</td>
            <td>VARCHAR(255)</td>
            <td>Item category</td>
          </tr>
          <tr>
            <td>price</td>
            <td>DECIMAL(10,2)</td>
            <td>Item price</td>
          </tr>
          <tr>
            <td>stock</td>
            <td>INT</td>
            <td>Stock count</td>
          </tr>
          <tr>
            <td>description</td>
            <td>TEXT</td>
            <td>Item description</td>
          </tr>
        </tbody>
      </table>

      <b>Table: orders</b>
      <table border="1">
        <thead>
          <tr>
            <th>Column</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>order_id</td>
            <td>VARCHAR(50)</td>
            <td>Primary Key</td>
          </tr>
          <tr>
            <td>user_id</td>
            <td>VARCHAR(50)</td>
            <td>Foreign Key to users</td>
          </tr>
          <tr>
            <td>status</td>
            <td>ENUM('created', 'placed', 'canceled', 'delivered')</td>
            <td>Order status</td>
          </tr>
          <tr>
            <td>total_price</td>
            <td>DECIMAL(10,2)</td>
            <td>Total order price</td>
          </tr>
          <tr>
            <td>created_at</td>
            <td>TIMESTAMP</td>
            <td>Order creation timestamp</td>
          </tr>
        </tbody>
      </table>

      <b>Table: order_items</b>
      <table border="1">
        <thead>
          <tr>
            <th>Column</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>order_item_id</td>
            <td>VARCHAR(50)</td>
            <td>Primary Key</td>
          </tr>
          <tr>
            <td>order_id</td>
            <td>VARCHAR(50)</td>
            <td>Foreign Key to orders</td>
          </tr>
          <tr>
            <td>item_id</td>
            <td>VARCHAR(50)</td>
            <td>Foreign Key to items</td>
          </tr>
          <tr>
            <td>quantity</td>
            <td>INT</td>
            <td>Quantity of the item</td>
          </tr>
          <tr>
            <td>price</td>
            <td>DECIMAL(10,2)</td>
            <td>Price of the item at the time of order</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div>
      <h5>2. MongoDB (Item Details)</h5>
      <p><strong>Collection: items</strong></p>
      <pre>
      {
        "_id": "item_id",
        "name": "Sony 65” TV",
        "category": "Electronics",
        "attributes": {
            "brand": "Sony",
            "resolution": "4K",
            "screen_size": "65 inches"
        },
        "stock": 10,
        "price": 999.99,
        "description": "A high-quality 4K TV with advanced features"
      }
            </pre
      >
    </div>

    <div>
      <h5>3. ElasticSearch (Search Index)</h5>
      <p><strong>Index: items</strong></p>
      <pre>
      {
        "item_id": "101",
        "name": "Sony 65” TV",
        "category": "Electronics",
        "price": 899.99,
        "stock": 5,
        "description": "A high-quality 4K TV with advanced features"
      }
            </pre
      >
    </div>

    <div>
      <h5>4. Redis (Order Cache)</h5>
      <p><strong>Key-Value Store:</strong></p>
      <pre>
      Key: order:o123
      Value: {
        "order_id": "o123",
        "user_id": "u123",
        "status": "created",
        "expiry_time": "2025-01-15T10:05:00Z"
      }
            </pre
      >
    </div>

    <div>
      <h5>5. Hadoop (Analytics Data)</h5>
      <p><strong>Schema Example:</strong></p>
      <pre>
      {
        "user_id": "u123",
        "search_query": "4K TV",
        "timestamp": "2025-01-15T10:01:00Z",
        "clicked_items": ["101", "102"]
      }
            </pre
      >
    </div>
  </div>
  <hr />
</div>
