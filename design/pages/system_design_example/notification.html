<div>
    <h2 style="text-align: center;">Notification Service</h2>
    <hr>
    <p>
        A notification system is designed to deliver timely and relevant information to users through multiple channels, including SMS, email, push notifications, and in-app messages. 
        For instance, it can notify users about an order confirmation via email, payment updates through SMS, and shipping details via push notifications, ensuring seamless communication across platforms.
    </p>
    <hr>

    <h5>Functional Requirements</h5>
    <ul>
        <li><b>Send Notifications:</b> Deliver notifications via email, SMS, push notifications, and in-app messages.</li>
        <li><b>Notification Types:</b> Handle transactional, promotional, and system-generated alerts.</li>
        <li><b>Scheduled Delivery:</b> Enable scheduling notifications for future delivery.</li>
        <li><b>Rate Limiting:</b> Restrict excessive promotional messages to prevent spam.</li>
        <li><b>Retry Mechanism:</b> Automatically retry failed notifications for seamless delivery.</li>
    </ul>
    <hr>

    <h5>Non-Functional Requirements:</h5>
    <ul>
        <li><b>Scalability:</b> Handle millions of notifications per minute, supporting millions of concurrent users.</li>
        <li><b>High Availability:</b> Ensure minimal downtime for uninterrupted notification delivery.</li>
        <li><b>Reliability:</b> Guarantee at-least-once delivery, with exactly-once semantics for critical use cases.</li>
        <li><b>Low Latency:</b> Deliver notifications quickly to ensure timely communication.</li>
      </ul>
    <hr>
    <h5>Estimation:</h5>
    <ul>
        <li><b>Users:</b> Assume the system serves 50 million daily active users.</li>
        <li><b>Notifications per user:</b> On average, each user receives 5 notifications/day.</li>
        <li><b>Peak Load:</b> During peak times, the system should handle 1 million notifications within 1 minute (e.g., during major events or flash sales).</li>
        <li><b>Notifications per day:</b> 50 million x 5 = 250 million notifications/day.</li>
        <li><b>Peak notifications per second:</b> 1 million / 60 = ~17,000 notifications/second.</li>
      </ul>

      <b>Storage:</b>
      <ul>
        <li><b>Daily Notifications:</b> 50 million notifications/day.</li>
        <li><b>Average Notification Size:</b> 1KB (including user data and metadata).</li>
        <li><b>Daily Storage Requirement:</b> 50 million notifications * 5 per user x 1KB = 250GB/day</li>
        <li><b>Monthly Storage Requirement:</b> 250GB/day x 30 days = 7.5TB/month.</li>
        <li><b>Yearly Storage Requirement:</b> 250B/day x 365 days = 91TB/year.</li>
      </ul>
    <hr>

    <div>
        <p>The Notification Service is used to send notifications to clients. There are two types of requests clients can make:</p>
        <ul>
          <li>Type 1: The request includes both the content and the channel (e.g., email) over which the notification will be sent.</li>
          <li>Type 2: The request includes the content and the user ID, and the system will decide the channel based on conditions like user preferences or system rules.</li>
        </ul>
        <p>For external systems, typically the request will be of the first type, where the channel is fixed. For internal systems, the request will include a user ID, and the system determines the best channel to use.</p>
      
        <p>Here's how the Notification Service works:</p>
        <ul>
          <li>When a request is sent, it's forwarded to Kafka (a messaging system).</li>
          <li>Kafkas passes the request to a <b>Notification Validator</b> and <b>Prioritizer</b> which checks if the content is valid (e.g., makes sure emails aren't missing or incorrect) and assigns a priority to the message based on its type (e.g., OTP messages are high priority, while promotional messages are low priority).</li>
          <li>The message is then forwarded to Kafka topics based on priority. High priority messages are handled first, followed by medium and low priority messages. This ensures that urgent notifications (like OTPs) are sent without delay.</li>
        </ul>
      
        <p>Next is the <b>Rate Limiter</b>, which does two things:</p>
        <ul>
          <li>It checks if a client is allowed to send the number of requests they've sent, based on their subscription plan. For example, an external system might have a limit on how many requests they can send per day.</li>
          <li>It checks how many notifications a user can receive. For instance, a user may be limited to only receiving a certain number of promotional messages per month.</li>
        </ul>
        <p>To track these limits, the system uses Redis (a fast memory database) to store a key that tracks requests for a certain period. If the limit is exceeded, the request is rejected.</p>
      
        <p>The Rate Limiter also helps with <b>Request Counting</b>. For clients who pay based on usage (pay-per-use model), instead of limiting their requests, the system counts the number of requests and generates reports to calculate their bill. This allows the system to track and charge clients based on how much they use the service.</p>
            <p>
              The Notification Handler and User Preferences Service are responsible for managing how users receive notifications. Users may choose to unsubscribe from promotional messages or prefer a certain channel for notifications. This is handled by the User Preferences Service, which interacts with a Preferences DB to store user settings and a User Service to fetch user information.
            </p>
            <ul>
              <li>
                <b>User Preferences:</b> Users can set limits on how many promotional messages they receive. For example, a user may only want to receive one promotional message per week.
              </li>
              <li>
                <b>Interaction with Rate Limiter:</b> If users set limits, the User Preferences Service will be placed before the Rate Limiter. This ensures users don’t get too many messages, and the rate of messages sent follows their preferences.
              </li>
              <li>
                <b>Notification Information:</b> Once we know the user’s contact info, preferred channels (like SMS, email, or push notifications), and content, we can send the notification.
              </li>
            </ul>
            
            <p>
              The information is sent as an event to Kafka. Kafka handles the routing to different message handlers based on the notification type, such as SMS, email, in-app notifications, etc.
            </p>
            <ul>
              <li>
                <b>Kafka:</b> Kafka is used to direct events (like a notification request) to the correct handler based on the type of message.
              </li>
              <li>
                <b>SMS Handler:</b> The SMS handler sends messages using different SMS vendors depending on the region (e.g., India, US, Europe). It decides which vendor to use based on the request priority.
              </li>
              <li>
                <b>Email Handler:</b> Similarly, the email handler interacts with email vendors to send out emails to users.
              </li>
              <li>
                <b>In-App Handler:</b> For in-app notifications, services like Firebase are used to send push notifications to users’ devices.
              </li>
              <li>
                <b>IVRS Handler:</b> For interactive voice responses, the IVRS handler sends confirmation or feedback calls to users.
              </li>
            </ul>
          
            <p>
              To ensure flexibility, if we need to add a new notification type (like WhatsApp), we can simply add a WhatsApp handler. Requests for WhatsApp notifications will automatically be directed to the WhatsApp handler without affecting other components.
            </p>
            
            <p>
              The final component is the Notification Tracker, which logs all sent notifications for auditing purposes. It stores this information in a database like Cassandra.
            </p>
            <ul>
              <li>
                <b>Notification Tracker:</b> Tracks all notifications for audit and record-keeping.
              </li>
              <li>
                <b>Cassandra:</b> A database that stores the history of all sent notifications permanently.
              </li>
            </ul>
            
            <p>
              Some components could be combined to simplify the system, and this can be decided during discussions with your interviewer.
            </p>
           
                <p>When you want to send out bulk notifications, a bulk notification service comes in handy. This service will have a user-friendly interface (UI) where you can specify who should receive the notification and what the message will be. The service will then take this information and send out notifications to the users who match your criteria.</p>
                
                <p>Here’s how it works:</p>
                
                <ul>
                  <li><b>User Transaction Data Service:</b> This is like a middleman that stores all the information about user transactions into various Kafka topics. Each transaction is recorded, such as purchases, logins, etc.</li>
                  <li><b>Search Functionality:</b> On top of these Kafka topics, we can build a search system that allows you to look up users based on specific filters, like finding users who made a purchase above a certain amount.</li>
                  <li><b>Transaction Data Parser:</b> A parser listens to the transactions happening in Kafka. It reads and understands these transactions, and then stores the data in a format like Elasticsearch or another data store.</li>
                  <li><b>Query Engine:</b> A system sits on top of the data store (like Elasticsearch). It allows you to filter users based on criteria such as location, purchase history, or account status.</li>
                </ul>
                
                <p>Once the query engine filters out users, the bulk notification service receives this list of filtered users and the content for the notifications. It then calls the notification service to send out the notifications to these users.</p>
                
                <p>The query engine may also have other consumers:</p>
                
                <ul>
                  <li><b>Rule Engines:</b> These perform certain actions based on conditions. For example, it might trigger an action if a user makes a large purchase.</li>
                  <li><b>Fraud Engines:</b> These systems check for suspicious activity, like multiple failed logins or unusual spending patterns.</li>
                  <li><b>Search Platforms:</b> Other services that allow searching or reporting based on user data.</li>
                </ul>
              </div>
            